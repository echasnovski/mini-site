---
title: "mini.hipatterns documentation"
toc-depth: 5
---

_Generated from the `main` branch of 'mini.nvim'_

<a name="mini.hipatterns" href="mini-hipatterns.qmd#mini.hipatterns"><b>mini.hipatterns</b></a> Highlight patterns in text

MIT License Copyright (c) 2023 Evgeni Chasnovski

---

### Module {#minihipatterns}

Features:

- Highlight text with configurable patterns and highlight groups (can be
  string or callable).


- Highlighting is updated asynchronously with configurable debounce delay.


- Function to get matches in a buffer (see [`MiniHipatterns.get_matches()`](mini-hipatterns.qmd#minihipatterns.get_matches)).

See [`MiniHipatterns-examples`](mini-hipatterns.qmd#minihipatterns-examples) for common configuration examples.

Notes:

- It does not define any highlighters by default. Add to `config.highlighters`
  to have a visible effect.


- Sometimes (especially during frequent buffer updates on same line numbers)
  highlighting can be outdated or not applied when it should be. This is due
  to asynchronous nature of updates reacting to text changes (via
  `on_lines` of [`nvim_buf_attach()`](https://neovim.io/doc/user/helptag.html?tag=nvim_buf_attach\(\))).
  To make them up to date, use one of the following:

    - Scroll window (for example, with [`CTRL-E`](https://neovim.io/doc/user/helptag.html?tag=CTRL-E) / [`CTRL-Y`](https://neovim.io/doc/user/helptag.html?tag=CTRL-Y)). This will ensure
      up to date highlighting inside window view.

    - Hide and show buffer.

    - Execute `:edit` (if you enabled highlighting with [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup)).

    - Manually call [`MiniHipatterns.update()`](mini-hipatterns.qmd#minihipatterns.update).


- If you experience flicker when typing near highlighted pattern in Insert
  mode, it might be due to `delay` configuration of [`mini.completion`](mini-completion.qmd#mini.completion) or
  using built-in completion.
  For better experience with 'mini.completion', make sure that its
  `delay.completion` is less than this module's `delay.text_change` (which
  it is by default).
  The reason for this is (currently unresolvable) limitations of Neovim's
  built-in completion implementation.

#### Setup {#minihipatterns-setup}


Setting up highlights can be done in two ways:

- Manually for every buffer with `require('mini.hipatterns').enable()`.
  This will enable highlighting only in one particular buffer until it is
  unloaded (which also includes calling `:edit` on current file).


- Globally with `require('mini.hipatterns').setup({})` (replace `{}` with
  your `config` table). This will auto-enable highlighting in "normal"
  buffers (see 'buftype'). Use [`MiniHipatterns.enable()`](mini-hipatterns.qmd#minihipatterns.enable) to manually enable
  in other buffers.
  It will also create global Lua table `MiniHipatterns` which you can use
  for scripting or manually (with `:lua MiniHipatterns.*`).

See [`MiniHipatterns.config`](mini-hipatterns.qmd#minihipatterns.config) for `config` structure and default values.

You can override runtime config settings (like highlighters and delays)
locally to buffer inside `vim.b.minihipatterns_config` which should have
same structure as `MiniHipatterns.config`.
See [`mini.nvim-buffer-local-config`](mini-nvim.qmd#mini.nvim-buffer-local-config) for more details.

#### Comparisons {#minihipatterns-comparisons}



- [folke/todo-comments](https://github.com/folke/todo-comments):

    - Oriented for "TODO", "NOTE", "FIXME" like patterns, while this module
      can work with any Lua patterns and computable highlight groups.

    - Has functionality beyond text highlighting (sign placing,
      "telescope.nvim" extension, etc.), while this module only focuses on
      highlighting text.

- [folke/paint.nvim](https://github.com/folke/paint.nvim):

    - Mostly similar to this module, but with slightly less functionality,
      such as computed pattern and highlight group, asynchronous delay, etc.

- [NvChad/nvim-colorizer.lua](https://github.com/NvChad/nvim-colorizer.lua):

    - Oriented for color highlighting, while this module can work with any
      Lua patterns and computable highlight groups.

    - Has more built-in color spaces to highlight, while this module out of
      the box provides only hex color highlighting
      (see [`MiniHipatterns.gen_highlighter.hex_color()`](mini-hipatterns.qmd#minihipatterns.gen_highlighter.hex_color)). Other types are
      also possible to implement.

- [uga-rosa/ccc.nvim](https://github.com/uga-rosa/ccc.nvim):

    - Has more than color highlighting functionality, which is compared to
      this module in the same way as 'NvChad/nvim-colorizer.lua'.

#### Highlight groups {#minihipatterns-highlightgroups}



- `MiniHipatternsFixme` - suggested group to use for `FIXME`-like patterns.

- `MiniHipatternsHack` - suggested group to use for `HACK`-like patterns.

- `MiniHipatternsTodo` - suggested group to use for `TODO`-like patterns.

- `MiniHipatternsNote` - suggested group to use for `NOTE`-like patterns.

To change any highlight group, set it directly with [`nvim_set_hl()`](https://neovim.io/doc/user/helptag.html?tag=nvim_set_hl\(\)).

#### Disabling {#minihipatterns-disabling}


This module can be disabled in three ways:

- Globally: set `vim.g.minihipatterns_disable` to `true`.

- Locally for buffer permanently: set `vim.b.minihipatterns_disable` to `true`.

- Locally for buffer temporarily (until next auto-enabling event if set up
  with [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup)): call [`MiniHipatterns.disable()`](mini-hipatterns.qmd#minihipatterns.disable).

Considering high number of different scenarios and customization
intentions, writing exact rules for disabling module's functionality is
left to user. See [`mini.nvim-disabling-recipes`](mini-nvim.qmd#mini.nvim-disabling-recipes) for common recipes.

---

### Examples {#minihipatterns-examples}

#### Common configuration examples {#minihipatterns-examples-commonconfigurationexamples}



- Special words used to convey different level of attention:

  ```lua
  require('mini.hipatterns').setup({
    highlighters = {
      fixme = { pattern = 'FIXME', group = 'MiniHipatternsFixme' },
      hack  = { pattern = 'HACK',  group = 'MiniHipatternsHack'  },
      todo  = { pattern = 'TODO',  group = 'MiniHipatternsTodo'  },
      note  = { pattern = 'NOTE',  group = 'MiniHipatternsNote'  },
    }
  })
  ```


- To match only when pattern appears as a standalone word, use frontier
  patterns `%f`. For example, instead of `'TODO'` pattern use
  `'%f[%w]()TODO()%f[%W]'`. In this case, for example, 'TODOING' or 'MYTODO'
  won't match, but 'TODO' and 'TODO:' will.


- Color hex (like `#rrggbb`) highlighting:

  ```lua
  local hipatterns = require('mini.hipatterns')
  hipatterns.setup({
    highlighters = {
      hex_color = hipatterns.gen_highlighter.hex_color(),
    }
  })
  ```

  You can customize which part of hex color is highlighted by using `style`
  field of input options. See [`MiniHipatterns.gen_highlighter.hex_color()`](mini-hipatterns.qmd#minihipatterns.gen_highlighter.hex_color).


- Colored words:

  ```lua
  local words = { red = '#ff0000', green = '#00ff00', blue = '#0000ff' }
  local word_color_group = function(_, match)
    local hex = words[match]
    if hex == nil then return nil end
    return MiniHipatterns.compute_hex_color_group(hex, 'bg')
  end

  local hipatterns = require('mini.hipatterns')
  hipatterns.setup({
    highlighters = {
      word_color = { pattern = '%S+', group = word_color_group },
    },
  })
  ```


- Trailing whitespace (if don't want to use more specific [`mini.trailspace`](mini-trailspace.qmd#mini.trailspace)):

  ```lua
  { pattern = '%f[%s]%s*$', group = 'Error' }
  ```


- Censor certain sensitive information:

  ```lua
  local censor_extmark_opts = function(_, match, _)
    local mask = string.rep('x', vim.fn.strchars(match))
    return {
      virt_text = { { mask, 'Comment' } }, virt_text_pos = 'overlay',
      priority = 200, right_gravity = false,
    }
  end

  require('mini.hipatterns').setup({
    highlighters = {
      censor = {
        pattern = 'password: ()%S+()',
        group = '',
        extmark_opts = censor_extmark_opts,
      },
    },
  })
  ```


- Enable only in certain filetypes. There are at least these ways to do it:

    - (Suggested) With `vim.b.minihipatterns_config` in [`filetype-plugin`](https://neovim.io/doc/user/helptag.html?tag=filetype-plugin).
      Basically, create "after/ftplugin/<span class="help-syntax-keys">\<filetype\></span>.lua" file in your config
      directory (see [`$XDG_CONFIG_HOME`](https://neovim.io/doc/user/helptag.html?tag=$XDG_CONFIG_HOME)) and define `vim.b.minihipatterns_config`
      there with filetype specific highlighters.

      This assumes `require('mini.hipatterns').setup()` call.

      For example, to highlight keywords in EmmyLua comments in Lua files,
      create "after/ftplugin/lua.lua" with the following content:

        ```lua
        vim.b.minihipatterns_config = {
          highlighters = {
            emmylua = { pattern = '^%s*%-%-%-()@%w+()', group = 'Special' }
          }
        }
        ```


    - Use callable `pattern` with condition. For example:

      ```lua
      require('mini.hipatterns').setup({
        highlighters = {
          emmylua = {
            pattern = function(buf_id)
              if vim.bo[buf_id].filetype ~= 'lua' then return nil end
              return '^%s*%-%-%-()@%w+()'
            end,
            group = 'Special',
          },
        },
      })
      ```


- Disable only in certain filetypes. Enable with [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup)
  and set `vim.b.minihipatterns_disable` buffer-local variable to `true` for
  buffer you want disabled. See [`mini.nvim-disabling-recipes`](mini-nvim.qmd#mini.nvim-disabling-recipes) for more examples.

---

### setup() {#minihipatterns.setup}

<p align="center">`MiniHipatterns.setup`(<span class="help-syntax-special">{config}</span>)</p>
Module setup

#### Parameters {#minihipatterns.setup-parameters}



<span class="help-syntax-special">{config}</span> `(table|nil)` Module config table. See [`MiniHipatterns.config`](mini-hipatterns.qmd#minihipatterns.config).

#### Usage {#minihipatterns.setup-usage}



  ```lua
  require('mini.hipatterns').setup({}) -- replace {} with your config table
                                       -- needs `highlighters` field present
  ```

---

### config {#minihipatterns.config}

<p align="center">`MiniHipatterns.config`</p>
#### Defaults {#minihipatterns.config-defaults}



  ```lua
  MiniHipatterns.config = {
    -- Table with highlighters (see |MiniHipatterns.config| for more details).
    -- Nothing is defined by default. Add manually for visible effect.
    highlighters = {},

    -- Delays (in ms) defining asynchronous highlighting process
    delay = {
      -- How much to wait for update after every text change
      text_change = 200,

      -- How much to wait for update after window scroll
      scroll = 50,
    },
  }
  ```

#### Highlighters {#minihipatterns.config-highlighters}


`highlighters` table defines which patterns will be highlighted by placing
[`extmark`](https://neovim.io/doc/user/helptag.html?tag=extmark) at the match start. It might or might not have explicitly named
fields, but having them is recommended and is required for proper use of
`vim.b.minihipatterns_config` as buffer-local config. By default it is
empty expecting user definition.

Each entry defines single highlighter as a table with the following fields:

- <span class="help-syntax-keys">\<pattern\></span> `(string|function|table)` - Lua pattern to highlight. Can be
  either string, callable returning the string, or an array of those.
  If string:

    - It can have submatch delimited by placing `()` on start and end, NOT
      by surrounding with it. Otherwise it will result in error
      containing `number expected, got string`. Example: `xx()abcd()xx`
      will match `abcd` only if `xx` is placed before and after it.

  If callable:

    - It will be called for every enabled buffer with its identifier as input.


    - It can return `nil` meaning this particular highlighter will not work
      in this particular buffer.

  If array:

    - Each element is matched and highlighted with the same highlight group.


- <span class="help-syntax-keys">\<group\></span> `(string|function)` - name of highlight group to use. Can be either
  string or callable returning the string.
  If callable:

    - It will be called for every pattern match with the following arguments:

        - `buf_id` - buffer identifier.

        - `match` - string pattern match to be highlighted.

        - `data` - extra table with information about the match.
          It has at least these fields:

            - <span class="help-syntax-keys">\<full_match\></span> - string with full pattern match.

            - <span class="help-syntax-keys">\<line\></span> - match line number (1-indexed).

            - <span class="help-syntax-keys">\<from_col\></span> - match starting byte column (1-indexed).

            - <span class="help-syntax-keys">\<to_col\></span> - match ending byte column (1-indexed, inclusive).


    - It can return `nil` meaning this particular match will not be highlighted.


- <span class="help-syntax-keys">\<extmark_opts\></span> `(table|function|nil)` - optional extra options
  for [`nvim_buf_set_extmark()`](https://neovim.io/doc/user/helptag.html?tag=nvim_buf_set_extmark\(\)). If callable, will be called in the same way
  as callable <span class="help-syntax-keys">\<group\></span> (`data` will also contain `hl_group` key with <span class="help-syntax-keys">\<group\></span>
  value) and should return a table with all options for extmark (including
  `end_row`, `end_col`, `hl_group`, and `priority`).

See "Common use cases" section for the examples.

#### Delay {#minihipatterns.config-delay}


`delay` is a table defining delays in milliseconds used for asynchronous
highlighting process.

`delay.text_change` is used to delay highlighting updates by accumulating
them (in debounce fashion). Smaller values will lead to faster response but
more frequent updates. Bigger - slower response but less frequent updates.

`delay.scroll` is used to delay updating highlights in current window view
during scrolling (see [`WinScrolled`](https://neovim.io/doc/user/helptag.html?tag=WinScrolled) event). These updates are present to
ensure up to date highlighting after scroll.

---

### enable() {#minihipatterns.enable}

<p align="center">`MiniHipatterns.enable`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{config}</span>)</p>
Enable highlighting in buffer

Notes:

- With default config it will highlight nothing, as there are no default
  highlighters.


- Buffer highlighting is enabled until buffer is unloaded from memory
  or [`MiniHipatterns.disable()`](mini-hipatterns.qmd#minihipatterns.disable) on this buffer is called.


- `:edit` disables this, as it is mostly equivalent to closing and opening
  buffer. In order for highlighting to persist after `:edit`, call
  [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup).

#### Parameters {#minihipatterns.enable-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number|nil)` Buffer identifier in which to enable highlighting.
  Default: 0 for current buffer.

<span class="help-syntax-special">{config}</span> `(table|nil)` Optional buffer-local config. Should have the same
  structure as [`MiniHipatterns.config`](mini-hipatterns.qmd#minihipatterns.config). Values will be taken in this order:

  - From this `config` argument (if supplied).

  - From buffer-local config in `vim.b.minihipatterns_config` (if present).

  - From global config (if [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup) was called).

  - From default values.

---

### disable() {#minihipatterns.disable}

<p align="center">`MiniHipatterns.disable`(<span class="help-syntax-special">{buf_id}</span>)</p>
Disable highlighting in buffer

Note that if [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup) was called, the effect is present
until the next auto-enabling event. To permanently disable highlighting in
buffer, set `vim.b.minihipatterns_disable` to `true`

#### Parameters {#minihipatterns.disable-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number|nil)` Buffer identifier in which to enable highlighting.
  Default: 0 for current buffer.

---

### toggle() {#minihipatterns.toggle}

<p align="center">`MiniHipatterns.toggle`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{config}</span>)</p>
Toggle highlighting in buffer

Call [`MiniHipatterns.disable()`](mini-hipatterns.qmd#minihipatterns.disable) if enabled; [`MiniHipatterns.enable()`](mini-hipatterns.qmd#minihipatterns.enable) otherwise.

#### Parameters {#minihipatterns.toggle-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number|nil)` Buffer identifier in which to enable highlighting.
  Default: 0 for current buffer.

<span class="help-syntax-special">{config}</span> `(table|nil)` Forwarded to [`MiniHipatterns.enable()`](mini-hipatterns.qmd#minihipatterns.enable).

---

### update() {#minihipatterns.update}

<p align="center">`MiniHipatterns.update`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{from_line}</span>, <span class="help-syntax-special">{to_line}</span>)</p>
Update highlighting in range

Works only in buffer with enabled highlighting. Effect takes immediately
without delay.

#### Parameters {#minihipatterns.update-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number|nil)` Buffer identifier in which to enable highlighting.
  Default: 0 for current buffer.

<span class="help-syntax-special">{from_line}</span> `(number|nil)` Start line from which to update (1-indexed).

<span class="help-syntax-special">{to_line}</span> `(number|nil)` End line from which to update (1-indexed, inclusive).

---

### get_enabled_buffers() {#minihipatterns.get_enabled_buffers}

<p align="center">`MiniHipatterns.get_enabled_buffers`()</p>
Get an array of enabled buffers

#### Return {#minihipatterns.get_enabled_buffers-return}


`(table)` Array of buffer identifiers with enabled highlighting.

---

### get_matches() {#minihipatterns.get_matches}

<p align="center">`MiniHipatterns.get_matches`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{highlighters}</span>)</p>
Get buffer matches

#### Parameters {#minihipatterns.get_matches-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number|nil)` Buffer identifier for which to return matches.
  Default: `nil` for current buffer.

<span class="help-syntax-special">{highlighters}</span> `(table|nil)` Array of highlighter identifiers (as in
  `highlighters` field of [`MiniHipatterns.config`](mini-hipatterns.qmd#minihipatterns.config)) for which to return matches.
  Default: all available highlighters (ordered by string representation).

#### Return {#minihipatterns.get_matches-return}


`(table)` Array of buffer matches which are tables with following fields:

  - <span class="help-syntax-keys">\<bufnr\></span> `(number)` - buffer identifier of a match.

  - <span class="help-syntax-keys">\<highlighter\></span> `(any)` - highlighter identifier which produced the match.

  - <span class="help-syntax-keys">\<lnum\></span> `(number)` - line number of the match start (starts with 1).

  - <span class="help-syntax-keys">\<col\></span> `(number)` - column number of the match start (starts with 1).

  - <span class="help-syntax-keys">\<end_lnum\></span> `(number|nil)` - line number of the match end (starts with 1).

  - <span class="help-syntax-keys">\<end_col\></span> `(number|nil)` - column number next to the match end
    (implements end-exclusive region; starts with 1).

  - <span class="help-syntax-keys">\<hl_group\></span> `(string|nil)` - name of match's highlight group.

  Matches are ordered first by supplied `highlighters`, then by line and
  column of match start.

---

### gen_highlighter {#minihipatterns.gen_highlighter}

<p align="center">`MiniHipatterns.gen_highlighter`</p>
Generate builtin highlighters

This is a table with function elements. Call to actually get highlighter.

---

### gen_highlighter.hex_color() {#minihipatterns.gen_highlighter.hex_color}

<p align="center">`MiniHipatterns.gen_highlighter.hex_color`(<span class="help-syntax-special">{opts}</span>)</p>
Highlight hex color string

This will match color hex string in format `#rrggbb` and highlight it
according to `opts.style` displaying matched color.

Highlight group is computed using [`MiniHipatterns.compute_hex_color_group()`](mini-hipatterns.qmd#minihipatterns.compute_hex_color_group),
so all its usage notes apply here.

#### Parameters {#minihipatterns.gen_highlighter.hex_color-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<style\></span> `(string)` - one of:

      - `'full'` -  highlight background of whole hex string with it. Default.

      - `'#'` - highlight background of only `#`.

      - `'line'` - highlight underline with that color.

      - `'inline'` - highlight text of <span class="help-syntax-keys">\<inline_text\></span>.
        Note: requires Neovim>=0.10.

  - <span class="help-syntax-keys">\<priority\></span> `(number)` - priority of highlighting. Default: 200.

  - <span class="help-syntax-keys">\<filter\></span> `(function)` - callable object used to filter buffers in which
    highlighting will take place. It should take buffer identifier as input
    and return `false` or `nil` to not highlight inside this buffer.

  - <span class="help-syntax-keys">\<inline_text\></span> `(string)` - string to be placed and highlighted with color
    to the right of match in case <span class="help-syntax-keys">\<style\></span> is "inline". Default: "█".

#### Return {#minihipatterns.gen_highlighter.hex_color-return}


`(table)` Highlighter table ready to be used as part of `config.highlighters`.
  Both `pattern` and `group` are callable.

#### Usage {#minihipatterns.gen_highlighter.hex_color-usage}



  ```lua
  local hipatterns = require('mini.hipatterns')
  hipatterns.setup({
    highlighters = {
      hex_color = hipatterns.gen_highlighter.hex_color(),
    }
  })
  ```

---

### compute_hex_color_group() {#minihipatterns.compute_hex_color_group}

<p align="center">`MiniHipatterns.compute_hex_color_group`(<span class="help-syntax-special">{hex_color}</span>, <span class="help-syntax-special">{style}</span>)</p>
Compute and create group to highlight hex color string

Notes:

- This works properly only with enabled [`'termguicolors'`](https://neovim.io/doc/user/helptag.html?tag='termguicolors').


- To increase performance, it caches highlight groups per `hex_color` and
  `style` combination. Needs a call to [`MiniHipatterns.setup()`](mini-hipatterns.qmd#minihipatterns.setup) to have
  these groups be persistent across color scheme changes.

#### Parameters {#minihipatterns.compute_hex_color_group-parameters}



<span class="help-syntax-special">{hex_color}</span> `(string)` Hex color string in format `#rrggbb`.

<span class="help-syntax-special">{style|nil}</span> `(string)` One of:

  - `'bg'` - highlight background with `hex_color` and foreground with black or
    white (whichever is more visible). Default.

  - `'fg'` - highlight foreground with `hex_color`.

  - `'line'` - highlight underline with `hex_color`.

#### Return {#minihipatterns.compute_hex_color_group-return}


`(string)` Name of created highlight group appropriate to show `hex_color`.

