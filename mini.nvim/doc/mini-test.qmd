---
title: "mini.test documentation"
toc-depth: 5
---

_Generated from the `main` branch of 'mini.nvim'_

<a name="mini.test" href="mini-test.qmd#mini.test"><b>mini.test</b></a> Test Neovim plugins

MIT License Copyright (c) 2022 Evgeni Chasnovski

---

### Module {#minitest}

Features:

- Test action is defined as a named callable entry of a table.


- Helper for creating child Neovim process which is designed to be used in
  tests (including taking and verifying screenshots). See
  [`MiniTest.new_child_neovim()`](mini-test.qmd#minitest.new_child_neovim) and [`MiniTest.expect.reference_screenshot()`](mini-test.qmd#minitest.expect.reference_screenshot).


- Hierarchical organization of tests with custom hooks, parametrization,
  and user data. See [`MiniTest.new_set()`](mini-test.qmd#minitest.new_set).


- Emulation of [lunarmodules/busted](https://github.com/lunarmodules/busted)
  interface (`describe`, `it`, etc.).


- Predefined small yet usable set of expectations (`assert`-like functions).
  See [`MiniTest.expect`](mini-test.qmd#minitest.expect).


- Customizable definition of what files should be tested.


- Test case filtering. There are predefined wrappers for testing a file
  ([`MiniTest.run_file()`](mini-test.qmd#minitest.run_file)) and case at a location like current cursor position
  ([`MiniTest.run_at_location()`](mini-test.qmd#minitest.run_at_location)).


- Customizable reporter of output results. There are two predefined ones:

    - [`MiniTest.gen_reporter.buffer()`](mini-test.qmd#minitest.gen_reporter.buffer) for interactive usage.

    - [`MiniTest.gen_reporter.stdout()`](mini-test.qmd#minitest.gen_reporter.stdout) for headless Neovim.


- Customizable project specific testing script.


- Works on Unix (Linux, MacOS, etc.) and Windows.

What it doesn't support:

- Parallel execution. Due to idea of limiting implementation complexity.


- Mocks, stubs, etc. Use child Neovim process and manually override what is
  needed. Reset child process it afterwards.


- "Overly specific" expectations. Tests for (no) equality and (absence of)
  errors usually cover most of the needs. Adding new expectations is a
  subject to weighing its usefulness against additional implementation
  complexity. Use [`MiniTest.new_expectation()`](mini-test.qmd#minitest.new_expectation) to create custom ones.

For more information see:

- 'TESTING.md' file for a hands-on introduction based on examples.


- Code of this plugin's tests. Consider it to be an example of intended
  way to use 'mini.test' for test organization and creation.

#### Workflow {#minitest-workflow}



- Organize tests in separate files. Each test file should return a test set
  (explicitly or implicitly by using "busted" style functions).


- Write test actions as callable entries of test set. Use child process
  inside test actions (see [`MiniTest.new_child_neovim()`](mini-test.qmd#minitest.new_child_neovim)) and builtin
  expectations (see [`MiniTest.expect`](mini-test.qmd#minitest.expect)).


- Run tests. This does two steps:

    - Collect. This creates single hierarchical test set, flattens into
      array of test cases (see [`MiniTest-test-case`](mini-test.qmd#minitest-test-case)) while expanding with
      parametrization, and possibly filters them.

    - Execute. This safely calls hooks and main test actions in specified
      order while allowing reporting progress in asynchronous fashion.
      Detected errors means test case fail; otherwise - pass.

#### Setup {#minitest-setup}


This module needs a setup with `require('mini.test').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniTest`
which you can use for scripting or manually (with `:lua MiniTest.*`).

See [`MiniTest.config`](mini-test.qmd#minitest.config) for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.minitest_config` which should have same structure as `MiniTest.config`.
See [`mini.nvim-buffer-local-config`](mini-nvim.qmd#mini.nvim-buffer-local-config) for more details.

To stop module from showing non-error feedback, set `config.silent = true`.

#### Comparisons {#minitest-comparisons}



- Testing infrastructure from
  [nvim-lua/plenary.nvim](https://github.com/nvim-lua/plenary.nvim):

    - Executes each file in separate headless Neovim process with customizable
      'init.vim' file. While 'mini.test' executes everything in current
      Neovim process encouraging writing tests with help of manually
      managed child Neovim process (see [`MiniTest.new_child_neovim()`](mini-test.qmd#minitest.new_child_neovim)).

    - Tests are expected to be written with embedded simplified versions of
      'lunarmodules/busted' and 'lunarmodules/luassert'. While 'mini.test'
      uses concepts of test set (see [`MiniTest.new_set()`](mini-test.qmd#minitest.new_set)) and test case
      (see [`MiniTest-test-case`](mini-test.qmd#minitest-test-case)). It also can emulate bigger part of
      "busted" framework.

    - Has single way of reporting progress (shows result after every case
      without summary). While 'mini.test' can have customized reporters
      with defaults for interactive and headless usage (provide more
      compact and user-friendly summaries).

    - Allows parallel execution, while 'mini.test' does not.

    - Allows making mocks, stubs, and spies, while 'mini.test' does not in
      favor of manually overwriting functionality in child Neovim process.

Although 'mini.test' supports emulation of "busted style" testing, it will
be more stable to use its designed approach of defining tests (with
`MiniTest.new_set()` and explicit table fields). Couple of reasons:

- "Busted" syntax doesn't support full capabilities offered by 'mini.test'.
  Mainly it is about parametrization and supplying user data to test sets.

- It is an emulation, not full support. So some subtle things might not
  work the way you expect.

Some hints for converting from 'plenary.nvim' tests to 'mini.test':

- Rename files from "*_spec.lua" to "test_*.lua" and put them in
  "tests" directory.

- Replace `assert` calls with 'mini.test' expectations. See [`MiniTest.expect`](mini-test.qmd#minitest.expect).

- Create main test set `T = MiniTest.new_set()` and eventually return it.

- Make new sets ([`MiniTest.new_set()`](mini-test.qmd#minitest.new_set)) from `describe` blocks. Convert
  `before_each()` and `after_each` to `pre_case` and `post_case` hooks.

- Make test cases from `it` blocks.

#### Highlight groups {#minitest-highlightgroups}



- `MiniTestEmphasis` - emphasis highlighting. By default it is a bold text.

- `MiniTestFail` - highlighting of failed cases. By default it is a bold
  text with `vim.g.terminal_color_1` color (red).

- `MiniTestPass` - highlighting of passed cases. By default it is a bold
  text with `vim.g.terminal_color_2` color (green).

To change any highlight group, set it directly with [`nvim_set_hl()`](https://neovim.io/doc/user/helptag.html?tag=nvim_set_hl\(\)).

#### Disabling {#minitest-disabling}


To disable, set `vim.g.minitest_disable` (globally) or `vim.b.minitest_disable`
(for a buffer) to `true`. Considering high number of different scenarios
and customization intentions, writing exact rules for disabling module's
functionality is left to user. See [`mini.nvim-disabling-recipes`](mini-nvim.qmd#mini.nvim-disabling-recipes) for common
recipes.

---

### setup() {#minitest.setup}

<p align="center">`MiniTest.setup`(<span class="help-syntax-special">{config}</span>)</p>
Module setup

#### Parameters {#minitest.setup-parameters}



<span class="help-syntax-special">{config}</span> `(table|nil)` Module config table. See [`MiniTest.config`](mini-test.qmd#minitest.config).

#### Usage {#minitest.setup-usage}



  ```lua
  require('mini.test').setup() -- use default config
  -- OR
  require('mini.test').setup({}) -- replace {} with your config table
  ```

---

### config {#minitest.config}

<p align="center">`MiniTest.config`</p>
#### Defaults {#minitest.config-defaults}



  ```lua
  MiniTest.config = {
    -- Options for collection of test cases. See `:h MiniTest.collect()`.
    collect = {
      -- Temporarily emulate functions from 'busted' testing framework
      -- (`describe`, `it`, `before_each`, `after_each`, and more)
      emulate_busted = true,

      -- Function returning array of file paths to be collected.
      -- Default: all Lua files in 'tests' directory starting with 'test_'.
      find_files = function()
        return vim.fn.globpath('tests', '**/test_*.lua', true, true)
      end,

      -- Predicate function indicating if test case should be executed
      filter_cases = function(case) return true end,
    },

    -- Options for execution of test cases. See `:h MiniTest.execute()`.
    execute = {
      -- Table with callable fields `start()`, `update()`, and `finish()`
      reporter = nil,

      -- Whether to stop execution after first error
      stop_on_error = false,
    },

    -- Path (relative to current directory) to script which handles project
    -- specific test running
    script_path = 'scripts/minitest.lua',

    -- Whether to disable showing non-error feedback
    silent = false,
  }
  ```

---

### current {#minitest.current}

<p align="center">`MiniTest.current`</p>
Table with information about current state of test execution

Use it to examine result of [`MiniTest.execute()`](mini-test.qmd#minitest.execute). It is reset at the
beginning of every call.

At least these keys are supported:

- <span class="help-syntax-keys">\<all_cases\></span> - array with all cases being currently executed. Basically,
  an input of `MiniTest.execute()`.

- <span class="help-syntax-keys">\<case\></span> - currently executed test case. See [`MiniTest-test-case`](mini-test.qmd#minitest-test-case). Use it
  to customize execution output (like adding custom notes, etc).

---

### new_set() {#minitest.new_set}

<p align="center">`MiniTest.new_set`(<span class="help-syntax-special">{opts}</span>, <span class="help-syntax-special">{tbl}</span>)</p>
Create test set

Test set is one of the two fundamental data structures. It is a table that
defines hierarchical test organization as opposed to sequential
organization with [`MiniTest-test-case`](mini-test.qmd#minitest-test-case).

All its elements are one of three categories:

- A callable (object that can be called; function or table with `__call`
  metatble entry) is considered to define a test action. It will be called
  with "current arguments" (result of all nested `parametrize` values, read
  further). If it throws error, test has failed.

- A test set (output of this function) defines nested structure. Its
  options during collection (see [`MiniTest.collect()`](mini-test.qmd#minitest.collect)) will be extended
  with options of this (parent) test set.

- Any other elements are considered helpers and don't directly participate
  in test structure.

Set options allow customization of test collection and execution (more
details in `opts` description):

- `hooks` - table with elements that will be called without arguments at
  predefined stages of test execution.

- `parametrize` - array defining different arguments with which main test
  actions will be called. Any non-trivial parametrization will lead to
  every element (even nested) be "multiplied" and processed with every
  element of `parametrize`. This allows handling many different combination
  of tests with little effort.

- `data` - table with user data that will be forwarded to cases. Primary
  objective is to be used for customized case filtering.

Notes:

- Preferred way of adding elements is by using syntax `T[name] = element`.
  This way order of added elements will be preserved. Any other way won't
  guarantee any order.

- Supplied options `opts` are stored in `opts` field of metatable
  (`getmetatable(set).opts`).

#### Parameters {#minitest.new_set-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Allowed options:

  - <span class="help-syntax-keys">\<hooks\></span> - table with fields:

      - <span class="help-syntax-keys">\<pre_once\></span> - executed before first filtered node.

      - <span class="help-syntax-keys">\<pre_case\></span> - executed before each case (even nested).

      - <span class="help-syntax-keys">\<post_case\></span> - executed after each case (even nested).

      - <span class="help-syntax-keys">\<post_once\></span> - executed after last filtered node.

  - <span class="help-syntax-keys">\<parametrize\></span> - array where each element is itself an array of
    parameters to be appended to "current parameters" of callable fields.
    Note: don't use plain `{}` as it is equivalent to "parametrization into
    zero cases", so no cases will be collected from this set. Calling test
    actions with no parameters is equivalent to `{{}}` or not supplying
    `parametrize` option at all.

  - <span class="help-syntax-keys">\<data\></span> - user data to be forwarded to cases. Can be used for a more
    granular filtering.

  - <span class="help-syntax-keys">\<n_retry\></span> - number of times to retry each case until success.
    Default: 1.

<span class="help-syntax-special">{tbl}</span> `(table|nil)` Initial test items (possibly nested). Will be executed
  without any guarantees on order.

#### Return {#minitest.new_set-return}


`(table)` A single test set.

#### Usage {#minitest.new_set-usage}



  ```lua
  -- Use with defaults
  T = MiniTest.new_set()
  T['works'] = function() MiniTest.expect.equality(1, 1) end

  -- Use with custom options. This will result into two actual cases: first
  -- will pass, second - fail after two attempts.
  T['nested'] = MiniTest.new_set({
    hooks = { pre_case = function() _G.x = 1 end },
    parametrize = { { 1 }, { 2 } },
    n_retry = 2,
  })

  T['nested']['works'] = function(x) MiniTest.expect.equality(_G.x, x) end
  ```

---

### Test case {#minitest-test-case}

Test case

An item of sequential test organization, as opposed to hierarchical with
test set (see [`MiniTest.new_set()`](mini-test.qmd#minitest.new_set)). It is created as result of test
collection with [`MiniTest.collect()`](mini-test.qmd#minitest.collect) to represent all necessary information
of test execution.

Execution of test case goes by the following rules:

- Call functions in order:

    - All elements of `hooks.pre` from first to last without arguments.

    - Field `test` with arguments unpacked from `args`. If execution fails,
      retry it (along with hooks that come from `pre_case` and `post_case`)
      at most `n_retry` times until first success (if any).

    - All elements of `hooks.post` from first to last without arguments.

- Error in any call gets appended to `exec.fails`, meaning error in any
  hook will lead to test fail.

- State (`exec.state`) is changed before every call and after last call.

#### Class {#minitest-test-case-class}



<span class="help-syntax-special">{Test-case}</span>

#### Fields {#minitest-test-case-fields}



<span class="help-syntax-special">{args}</span> `(table)` Array of arguments with which `test` will be called.

<span class="help-syntax-special">{data}</span> `(table)` User data: all fields of `opts.data` from nested test sets.

<span class="help-syntax-special">{desc}</span> `(table)` Description: array of fields from nested test sets.

<span class="help-syntax-special">{exec}</span> `(table|nil)` Information about test case execution. Value of `nil` means
  that this particular case was not (yet) executed. Has following fields:

  - <span class="help-syntax-keys">\<fails\></span> - array of strings with failing information.

  - <span class="help-syntax-keys">\<notes\></span> - array of strings with non-failing information.

  - <span class="help-syntax-keys">\<state\></span> - state of test execution. One of:

      - 'Executing <name of what is being executed>' (during execution).

      - 'Pass' (no fails, no notes).

      - 'Pass with notes' (no fails, some notes).

      - 'Fail' (some fails, no notes).

      - 'Fail with notes' (some fails, some notes).

<span class="help-syntax-special">{hooks}</span> `(table)` Hooks to be executed as part of test case. Has fields:

  - <span class="help-syntax-keys">\<pre\></span> and <span class="help-syntax-keys">\<post\></span> - arrays of functions to be consecutively executed
    before and after every execution of `test`.

  - <span class="help-syntax-keys">\<pre_source\></span> and <span class="help-syntax-keys">\<post_source\></span> - arrays of strings with sources of
    corresponding elements in <span class="help-syntax-keys">\<pre\></span> and <span class="help-syntax-keys">\<post\></span> arrays. Source is one of
    `"once"` (for `pre_once` and `post_once` hooks) and
    `"case"` (for `pre_case` and `post_case` hooks).

<span class="help-syntax-special">{test}</span> `(function|table)` Main callable object representing test action.

---

### skip() {#minitest.skip}

<p align="center">`MiniTest.skip`(<span class="help-syntax-special">{msg}</span>)</p>
Skip the rest of current case

Notes:

- When called inside test case, stops execution while adding message to notes.

- When called inside `pre_case` hook, registers skip at the start of its
  test case. Calling in other hooks has no effect.

- Currently implemented as a specially handled type of error.

#### Parameters {#minitest.skip-parameters}



<span class="help-syntax-special">{msg}</span> `(string|nil)` Message to be added to current case notes.

---

### add_note() {#minitest.add_note}

<p align="center">`MiniTest.add_note`(<span class="help-syntax-special">{msg}</span>)</p>
Add note to currently executed test case

Appends `msg` to `exec.notes` field of `case` in [`MiniTest.current`](mini-test.qmd#minitest.current).

#### Parameters {#minitest.add_note-parameters}



<span class="help-syntax-special">{msg}</span> `(string)` Note to add.

---

### finally() {#minitest.finally}

<p align="center">`MiniTest.finally`(<span class="help-syntax-special">{f}</span>)</p>
Register callable execution after current callable

Can be used several times inside hooks and main test callable of test case.

#### Parameters {#minitest.finally-parameters}



<span class="help-syntax-special">{f}</span> `(function|table)` Callable to be executed after current callable is
  finished executing (regardless of whether it ended with error or not).

---

### run() {#minitest.run}

<p align="center">`MiniTest.run`(<span class="help-syntax-special">{opts}</span>)</p>
Run tests


- Try executing project specific script at path `opts.script_path`. If
  successful (no errors), then stop.

- Collect cases with [`MiniTest.collect()`](mini-test.qmd#minitest.collect) and `opts.collect`.

- Execute collected cases with [`MiniTest.execute()`](mini-test.qmd#minitest.execute) and `opts.execute`.

#### Parameters {#minitest.run-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options with structure similar to [`MiniTest.config`](mini-test.qmd#minitest.config).
  Absent values are inferred from there.

---

### run_file() {#minitest.run_file}

<p align="center">`MiniTest.run_file`(<span class="help-syntax-special">{file}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Run specific test file

Basically a [`MiniTest.run()`](mini-test.qmd#minitest.run) wrapper with custom `collect.find_files` option.

#### Parameters {#minitest.run_file-parameters}



<span class="help-syntax-special">{file}</span> `(string|nil)` Path to test file. By default a path of current buffer.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options for [`MiniTest.run()`](mini-test.qmd#minitest.run).

---

### run_at_location() {#minitest.run_at_location}

<p align="center">`MiniTest.run_at_location`(<span class="help-syntax-special">{location}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Run case(s) covering location

Try filtering case(s) covering location, meaning that definition of its
main `test` action (as taken from builtin `debug.getinfo`) is located in
specified file and covers specified line. Note that it can result in
multiple cases if they come from parametrized test set (see `parametrize`
option in [`MiniTest.new_set()`](mini-test.qmd#minitest.new_set)).

Basically a [`MiniTest.run()`](mini-test.qmd#minitest.run) wrapper with custom `collect.find_files` option.

#### Parameters {#minitest.run_at_location-parameters}



<span class="help-syntax-special">{location}</span> `(table|nil)` Table with fields <span class="help-syntax-keys">\<file\></span> (path to file) and <span class="help-syntax-keys">\<line\></span>
  (line number in that file). Default is taken from current cursor position.

---

### collect() {#minitest.collect}

<p align="center">`MiniTest.collect`(<span class="help-syntax-special">{opts}</span>)</p>
Collect test cases

Overview of collection process:

- If `opts.emulate_busted` is `true`, temporary make special global
  functions (removed at the end of collection). They can be used inside
  test files to create hierarchical structure of test cases.

- Source each file from array output of `opts.find_files`. It should output
  a test set (see [`MiniTest.new_set()`](mini-test.qmd#minitest.new_set)) or `nil` (if "busted" style is used;
  test set is created implicitly).

- Combine all test sets into single set with fields equal to its file path.

- Convert from hierarchical test configuration to sequential: from single
  test set to array of test cases (see [`MiniTest-test-case`](mini-test.qmd#minitest-test-case)). Conversion is
  done in the form of "for every table element do: for every `parametrize`
  element do: ...". Details:

    - If element is a callable, construct test case with it being main
      `test` action. Description is appended with key of element in current
      test set table. Hooks, arguments, and data are taken from "current
      nested" ones. Add case to output array.

    - If element is a test set, process it in similar, recursive fashion.
      The "current nested" information is expanded:

        - `args` is extended with "current element" from `parametrize`.

        - `desc` is appended with element key.

        - `hooks` are appended to their appropriate places. `*_case` hooks
          will be inserted closer to all child cases than hooks from parent
          test sets: `pre_case` at end, `post_case` at start.

        - `data` is extended via [`vim.tbl_deep_extend()`](https://neovim.io/doc/user/helptag.html?tag=vim.tbl_deep_extend\(\)).

    - Any other element is not processed.

- Filter array with `opts.filter_cases`. Note that input case doesn't contain
  all hooks, as `*_once` hooks will be added after filtration.

- Add `*_once` hooks to appropriate cases.

#### Parameters {#minitest.collect-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options controlling case collection. Possible fields:

  - <span class="help-syntax-keys">\<emulate_busted\></span> - whether to emulate 'lunarmodules/busted' interface.
    It emulates these global functions: `describe`, `it`, `setup`, `teardown`,
<p align="center">`before_each`, `after_each`. Use [`MiniTest.skip()`](mini-test.qmd#minitest.skip) instead of `pending()`</p>
    and [`MiniTest.finally()`](mini-test.qmd#minitest.finally) instead of `finally`.

  - <span class="help-syntax-keys">\<find_files\></span> - function which when called without arguments returns
    array with file paths. Each file should be a Lua file returning single
    test set or `nil`.

  - <span class="help-syntax-keys">\<filter_cases\></span> - function which when called with single test case
    (see [`MiniTest-test-case`](mini-test.qmd#minitest-test-case)) returns `false` if this case should be filtered
    out; `true` otherwise.

#### Return {#minitest.collect-return}


`(table)` Array of test cases ready to be used by [`MiniTest.execute()`](mini-test.qmd#minitest.execute).

---

### execute() {#minitest.execute}

<p align="center">`MiniTest.execute`(<span class="help-syntax-special">{cases}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Execute array of test cases

Overview of execution process:

- Reset `all_cases` in [`MiniTest.current`](mini-test.qmd#minitest.current) with `cases` input.

- Call `reporter.start(cases)` (if present).

- Execute each case in natural array order (aligned with their integer
  keys). Set `MiniTest.current.case` to currently executed case. Detailed
  test case execution is described in [`MiniTest-test-case`](mini-test.qmd#minitest-test-case). After any state
  change (including case retry attempts), call `reporter.update(case_num)`
  (if present), where `case_num` is an integer key of current test case.

- Call `reporter.finish()` (if present).

Notes:

- Execution is done in asynchronous fashion with scheduling. This allows
  making meaningful progress report during execution.

- This function doesn't return anything. Instead, it updates `cases` in
  place with proper `exec` field. Use `all_cases` at [`MiniTest.current`](mini-test.qmd#minitest.current) to
  look at execution result.

#### Parameters {#minitest.execute-parameters}



<span class="help-syntax-special">{cases}</span> `(table)` Array of test cases (see [`MiniTest-test-case`](mini-test.qmd#minitest-test-case)).

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options controlling case collection. Possible fields:

  - <span class="help-syntax-keys">\<reporter\></span> - table with possible callable fields `start`, `update`,
    `finish`. Default: [`MiniTest.gen_reporter.buffer()`](mini-test.qmd#minitest.gen_reporter.buffer) in interactive
    usage and [`MiniTest.gen_reporter.stdout()`](mini-test.qmd#minitest.gen_reporter.stdout) in headless usage.

  - <span class="help-syntax-keys">\<stop_on_error\></span> - whether to stop execution (see [`MiniTest.stop()`](mini-test.qmd#minitest.stop))
    after first error. Default: `false`.

---

### stop() {#minitest.stop}

<p align="center">`MiniTest.stop`(<span class="help-syntax-special">{opts}</span>)</p>
Stop test execution

#### Parameters {#minitest.stop-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options with fields:

  - <span class="help-syntax-keys">\<close_all_child_neovim\></span> - whether to close all child neovim processes
    created with [`MiniTest.new_child_neovim()`](mini-test.qmd#minitest.new_child_neovim). Default: `true`.

---

### is_executing() {#minitest.is_executing}

<p align="center">`MiniTest.is_executing`()</p>
Check if tests are being executed

#### Return {#minitest.is_executing-return}


`(boolean)`

---

### expect {#minitest.expect}

<p align="center">`MiniTest.expect`</p>
Table with expectation functions

Each function has the following behavior:

- Silently returns `true` if expectation is fulfilled.

- Throws an informative error with information helpful for debugging.

Mostly designed to be used within 'mini.test' framework.

#### Usage {#minitest.expect-usage}



  ```lua
  local x = 1 + 1
  MiniTest.expect.equality(x, 2) -- passes
  MiniTest.expect.equality(x, 1) -- fails
  ```

---

### expect.equality() {#minitest.expect.equality}

<p align="center">`MiniTest.expect.equality`(<span class="help-syntax-special">{left}</span>, <span class="help-syntax-special">{right}</span>)</p>
Expect equality of two objects

Equality is tested via [`vim.deep_equal()`](https://neovim.io/doc/user/helptag.html?tag=vim.deep_equal\(\)).

#### Parameters {#minitest.expect.equality-parameters}



<span class="help-syntax-special">{left}</span> `(any)` First object.

<span class="help-syntax-special">{right}</span> `(any)` Second object.

---

### expect.no_equality() {#minitest.expect.no_equality}

<p align="center">`MiniTest.expect.no_equality`(<span class="help-syntax-special">{left}</span>, <span class="help-syntax-special">{right}</span>)</p>
Expect no equality of two objects

Equality is tested via [`vim.deep_equal()`](https://neovim.io/doc/user/helptag.html?tag=vim.deep_equal\(\)).

#### Parameters {#minitest.expect.no_equality-parameters}



<span class="help-syntax-special">{left}</span> `(any)` First object.

<span class="help-syntax-special">{right}</span> `(any)` Second object.

---

### expect.error() {#minitest.expect.error}

<p align="center">`MiniTest.expect.error`(<span class="help-syntax-special">{f}</span>, <span class="help-syntax-special">{pattern}</span>, <span class="help-syntax-special">{...}</span>)</p>
Expect function call to raise error

#### Parameters {#minitest.expect.error-parameters}



<span class="help-syntax-special">{f}</span> `(function|table)` Callable to be tested for raising error.

<span class="help-syntax-special">{pattern}</span> `(string|nil)` Pattern which error message should match.
  Use `nil` or empty string to not test for pattern matching.

<span class="help-syntax-special">{...}</span> `(any)` Extra arguments with which `f` will be called.

---

### expect.no_error() {#minitest.expect.no_error}

<p align="center">`MiniTest.expect.no_error`(<span class="help-syntax-special">{f}</span>, <span class="help-syntax-special">{...}</span>)</p>
Expect function call to not raise error

#### Parameters {#minitest.expect.no_error-parameters}



<span class="help-syntax-special">{f}</span> `(function|table)` Callable to be tested for raising error.

<span class="help-syntax-special">{...}</span> `(any)` Extra arguments with which `f` will be called.

---

### expect.reference_screenshot() {#minitest.expect.reference_screenshot}

<p align="center">`MiniTest.expect.reference_screenshot`(<span class="help-syntax-special">{screenshot}</span>, <span class="help-syntax-special">{path}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Expect equality to reference screenshot

#### Parameters {#minitest.expect.reference_screenshot-parameters}



<span class="help-syntax-special">{screenshot}</span> `(table|nil)` Array with screenshot information. Usually an output
  of `child.get_screenshot()` (see [`MiniTest-child-neovim-get_screenshot()`](mini-test.qmd#minitest-child-neovim-get_screenshot)).
  If `nil`, expectation passed.

<span class="help-syntax-special">{path}</span> `(string|nil)` Path to reference screenshot. If `nil`, constructed
  automatically in directory `opts.directory` from current case info and
  total number of times it was called inside current case. If there is no
  file at `path`, it is created with content of `screenshot`.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options:

  - <span class="help-syntax-keys">\<force\></span> `(boolean)` - whether to forcefully create reference screenshot.
    Temporary useful during test writing. Default: `false`.

  - <span class="help-syntax-keys">\<ignore_text\></span> `(boolean|table)` - whether to ignore all or some text lines.
    If `true` - ignore all, if number array - ignore text of those lines,
    if `false` - do not ignore any. Default: `false`.

  - <span class="help-syntax-keys">\<ignore_attr\></span> `(boolean|table)` - whether to ignore all or some attr lines.
    If `true` - ignore all, if number array - ignore attr of those lines,
    if `false` - do not ignore any. Default: `false`.

  - <span class="help-syntax-keys">\<directory\></span> `(string)` - directory where automatically constructed `path`
    is located. Default: "tests/screenshots".

---

### new_expectation() {#minitest.new_expectation}

<p align="center">`MiniTest.new_expectation`(<span class="help-syntax-special">{subject}</span>, <span class="help-syntax-special">{predicate}</span>, <span class="help-syntax-special">{fail_context}</span>)</p>
Create new expectation function

Helper for writing custom functions with behavior similar to other methods
of [`MiniTest.expect`](mini-test.qmd#minitest.expect).

#### Parameters {#minitest.new_expectation-parameters}



<span class="help-syntax-special">{subject}</span> `(string|function|table)` Subject of expectation. If callable,
  called with expectation input arguments to produce string value.

<span class="help-syntax-special">{predicate}</span> `(function|table)` Predicate callable. Called with expectation
  input arguments. Output `false` or `nil` means failed expectation.

<span class="help-syntax-special">{fail_context}</span> `(string|function|table)` Information about fail. If callable,
  called with expectation input arguments to produce string value.

#### Return {#minitest.new_expectation-return}


`(function)` Expectation function.

#### Usage {#minitest.new_expectation-usage}



  ```lua
  local expect_truthy = MiniTest.new_expectation(
    'truthy',
    function(x) return x end,
    function(x) return 'Object: ' .. vim.inspect(x) end
  )
  ```

---

### gen_reporter {#minitest.gen_reporter}

<p align="center">`MiniTest.gen_reporter`</p>
Table with pre-configured report generators

Each element is a function which returns reporter - table with callable
`start`, `update`, and `finish` fields.

---

### gen_reporter.buffer() {#minitest.gen_reporter.buffer}

<p align="center">`MiniTest.gen_reporter.buffer`(<span class="help-syntax-special">{opts}</span>)</p>
Generate buffer reporter

This is a default choice for interactive (not headless) usage. Opens a window
with dedicated non-terminal buffer and updates it with throttled redraws.

Opened buffer has the following helpful Normal mode mappings:

- `<Esc>` - stop test execution if executing (see [`MiniTest.is_executing()`](mini-test.qmd#minitest.is_executing)
  and [`MiniTest.stop()`](mini-test.qmd#minitest.stop)). Close window otherwise.

- `q` - same as `<Esc>` for convenience and compatibility.

General idea:

- Group cases by concatenating first `opts.group_depth` elements of case
  description (`desc` field). Groups by collected files if using default values.

- In `start()` show some stats to know how much is scheduled to be executed.

- In `update()` show symbolic overview of current group and state of current
  case. Each symbol represents one case and its state:

    - `?` - case didn't finish executing.

    - `o` - pass.

    - `O` - pass with notes.

    - `x` - fail.

    - `X` - fail with notes.

- In `finish()` show all fails and notes ordered by case.

#### Parameters {#minitest.gen_reporter.buffer-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Table with options. Used fields:

  - <span class="help-syntax-keys">\<group_depth\></span> - number of first elements of case description (can be zero)
    used for grouping. Higher values mean higher granularity of output.
    Default: 1.

  - <span class="help-syntax-keys">\<throttle_delay\></span> - minimum number of milliseconds to wait between
    redrawing. Reduces screen flickering but not amount of computations.
    Default: 10.

  - <span class="help-syntax-keys">\<window\></span> - definition of window to open. Can take one of the forms:

      - Callable. It is called expecting output to be target window id
        (current window is used if output is `nil`). Use this to open in
        "normal" window (like `function() vim.cmd('vsplit') end`).

      - Table. Used as `config` argument in [`nvim_open_win()`](https://neovim.io/doc/user/helptag.html?tag=nvim_open_win\(\)).
    Default: table for centered floating window.

---

### gen_reporter.stdout() {#minitest.gen_reporter.stdout}

<p align="center">`MiniTest.gen_reporter.stdout`(<span class="help-syntax-special">{opts}</span>)</p>
Generate stdout reporter

This is a default choice for headless usage. Writes to `stdout`. Uses
coloring ANSI escape sequences to make pretty and informative output
(should work in most modern terminals and continuous integration providers).

It has same general idea as [`MiniTest.gen_reporter.buffer()`](mini-test.qmd#minitest.gen_reporter.buffer) with slightly
less output (it doesn't overwrite previous text) to overcome typical
terminal limitations.

#### Parameters {#minitest.gen_reporter.stdout-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Table with options. Used fields:

  - <span class="help-syntax-keys">\<group_depth\></span> - number of first elements of case description (can be zero)
    used for grouping. Higher values mean higher granularity of output.
    Default: 1.

  - <span class="help-syntax-keys">\<quit_on_finish\></span> - whether to quit after finishing test execution.
    Default: `true`.

---

### new_child_neovim() {#minitest.new_child_neovim}

<p align="center">`MiniTest.new_child_neovim`()</p>
Create child Neovim process

This creates an object designed to be a fundamental piece of 'mini.test'
methodology. It can start/stop/restart a separate (child) Neovim process
(headless, but fully functioning) together with convenience helpers to
interact with it through [`RPC`](https://neovim.io/doc/user/helptag.html?tag=RPC) messages.

For more information see [`MiniTest-child-neovim`](mini-test.qmd#minitest-child-neovim).

#### Return {#minitest.new_child_neovim-return}


`(MiniTest.child)` Object of [`MiniTest-child-neovim`](mini-test.qmd#minitest-child-neovim).

#### Usage {#minitest.new_child_neovim-usage}



  ```lua
  -- Initiate
  local child = MiniTest.new_child_neovim()
  child.start()

  -- Use API functions
  child.api.nvim_buf_set_lines(0, 0, -1, true, { 'Line inside child Neovim' })

  -- Execute Lua code, Vimscript commands, etc.
  child.lua('_G.n = 0')
  child.cmd('au CursorMoved * lua _G.n = _G.n + 1')
  child.type_keys('l')
  print(child.lua_get('_G.n')) -- Should be 1

  -- Use other `vim.xxx` Lua wrappers (executed inside child process)
  vim.b.aaa = 'current process'
  child.b.aaa = 'child process'
  print(child.lua_get('vim.b.aaa')) -- Should be 'child process'

  -- Always stop process after it is not needed
  child.stop()
  ```

---

### Child neovim {#minitest-child-neovim}

Child class

It offers a great set of tools to write reliable and reproducible tests by
allowing to use fresh process in any test action. Interaction with it is done
through [`RPC`](https://neovim.io/doc/user/helptag.html?tag=RPC) protocol.

Although quite flexible, at the moment it has certain limitations:

- Doesn't allow using functions or userdata for child's both inputs and
  outputs. Usual solution is to move computations from current Neovim process
  to child process. Use `child.lua()` and `child.lua_get()` for that.

- When writing tests, it is common to end up with "hanging" process: it
  stops executing without any output. Most of the time it is because Neovim
  process is "blocked", i.e. it waits for user input and won't return from
  other call (like `child.api.nvim_exec_lua()`). Common causes are active
  [`hit-enter-prompt`](https://neovim.io/doc/user/helptag.html?tag=hit-enter-prompt) (increase prompt height to a bigger value) or
  Operator-pending mode (exit it). To mitigate this experience, most helpers
  will throw an error if its immediate execution will lead to hanging state.
  Also in case of hanging state try `child.api_notify` instead of `child.api`.

Notes:

- An important type of field is a "redirection table". It acts as a
  convenience wrapper for corresponding `vim.*` table. Can be used both to
  return and set values. Examples:

    - `child.api.nvim_buf_line_count(0)` will execute
      `vim.api.nvim_buf_line_count(0)` inside child process and return its
      output to current process.

    - `child.bo.filetype = 'lua'` will execute `vim.bo.filetype = 'lua'`
      inside child process.
  They still have same limitations listed above, so are not perfect. In
  case of a doubt, use `child.lua()`.

- Almost all methods use [`vim.rpcrequest()`](https://neovim.io/doc/user/helptag.html?tag=vim.rpcrequest\(\)) (i.e. wait for call to finish and
  then return value). See for `*_notify` variant to use [`vim.rpcnotify()`](https://neovim.io/doc/user/helptag.html?tag=vim.rpcnotify\(\)).

- All fields and methods should be called with `.`, not `:`.

#### Class {#minitest-child-neovim-class}



<span class="help-syntax-special">{MiniTest.child}</span>

#### Fields {#minitest-child-neovim-fields}



<span class="help-syntax-special">{start}</span> `(function)` Start child process. See [`MiniTest-child-neovim-start()`](mini-test.qmd#minitest-child-neovim-start).

<span class="help-syntax-special">{stop}</span> `(function)` Stop current child process.

<span class="help-syntax-special">{restart}</span> `(function)` Restart child process: stop if running and then
  start a new one. Takes same arguments as `child.start()` but uses values
  from most recent `start()` call as defaults.


<span class="help-syntax-special">{type_keys}</span> `(function)` Emulate typing keys.
  See [`MiniTest-child-neovim-type_keys()`](mini-test.qmd#minitest-child-neovim-type_keys). Doesn't check for blocked state.


<span class="help-syntax-special">{cmd}</span> `(function)` Execute Vimscript code from a string.
  A wrapper for [`nvim_exec()`](https://neovim.io/doc/user/helptag.html?tag=nvim_exec\(\)) without capturing output.

<span class="help-syntax-special">{cmd_capture}</span> `(function)` Execute Vimscript code from a string and
  capture output. A wrapper for [`nvim_exec()`](https://neovim.io/doc/user/helptag.html?tag=nvim_exec\(\)) with capturing output.


<span class="help-syntax-special">{lua}</span> `(function)` Execute Lua code. A wrapper for [`nvim_exec_lua()`](https://neovim.io/doc/user/helptag.html?tag=nvim_exec_lua\(\)).

<span class="help-syntax-special">{lua_notify}</span> `(function)` Execute Lua code without waiting for output.

<span class="help-syntax-special">{lua_get}</span> `(function)` Execute Lua code and return result. A wrapper
  for [`nvim_exec_lua()`](https://neovim.io/doc/user/helptag.html?tag=nvim_exec_lua\(\)) but prepends string code with `return`.

<span class="help-syntax-special">{lua_func}</span> `(function)` Execute Lua function and return it's result.
  Function will be called with all extra parameters (second one and later).
  Note: usage of upvalues (data from outside function scope) is not allowed.


<span class="help-syntax-special">{is_blocked}</span> `(function)` Check whether child process is blocked.

<span class="help-syntax-special">{is_running}</span> `(function)` Check whether child process is currently running.


<span class="help-syntax-special">{ensure_normal_mode}</span> `(function)` Ensure normal mode.

<span class="help-syntax-special">{get_screenshot}</span> `(function)` Returns table with two "2d arrays" of single
  characters representing what is displayed on screen and how it looks.
  Has `opts` table argument for optional configuratnion.


<span class="help-syntax-special">{job}</span> `(table|nil)` Information about current job. If `nil`, child is not running.


<span class="help-syntax-special">{api}</span> `(table)` Redirection table for `vim.api`. Doesn't check for blocked state.

<span class="help-syntax-special">{api_notify}</span> `(table)` Same as `api`, but uses [`vim.rpcnotify()`](https://neovim.io/doc/user/helptag.html?tag=vim.rpcnotify\(\)).


<span class="help-syntax-special">{diagnostic}</span> `(table)` Redirection table for [`vim.diagnostic`](https://neovim.io/doc/user/helptag.html?tag=vim.diagnostic).

<span class="help-syntax-special">{fn}</span> `(table)` Redirection table for [`vim.fn`](https://neovim.io/doc/user/helptag.html?tag=vim.fn).

<span class="help-syntax-special">{highlight}</span> `(table)` Redirection table for [`vim.highlight`](https://neovim.io/doc/user/helptag.html?tag=vim.highlight).

<span class="help-syntax-special">{hl}</span> `(table)` Redirection table for [`vim.hl`](https://neovim.io/doc/user/helptag.html?tag=vim.hl).

<span class="help-syntax-special">{json}</span> `(table)` Redirection table for `vim.json`.

<span class="help-syntax-special">{loop}</span> `(table)` Redirection table for [`vim.loop`](https://neovim.io/doc/user/helptag.html?tag=vim.loop).

<span class="help-syntax-special">{lsp}</span> `(table)` Redirection table for `vim.lsp` ([`lsp-core`](https://neovim.io/doc/user/helptag.html?tag=lsp-core)).

<span class="help-syntax-special">{mpack}</span> `(table)` Redirection table for [`vim.mpack`](https://neovim.io/doc/user/helptag.html?tag=vim.mpack).

<span class="help-syntax-special">{spell}</span> `(table)` Redirection table for [`vim.spell`](https://neovim.io/doc/user/helptag.html?tag=vim.spell).

<span class="help-syntax-special">{treesitter}</span> `(table)` Redirection table for `vim.treesitter` ([`lua-treesitter-core`](https://neovim.io/doc/user/helptag.html?tag=lua-treesitter-core)).

<span class="help-syntax-special">{ui}</span> `(table)` Redirection table for [`vim.ui`](https://neovim.io/doc/user/helptag.html?tag=vim.ui). Currently of no
  use because it requires sending function through RPC, which is impossible
  at the moment.

<span class="help-syntax-special">{fs}</span> `(table)` Redirection table for [`vim.fs`](https://neovim.io/doc/user/helptag.html?tag=vim.fs).


<span class="help-syntax-special">{g}</span> `(table)` Redirection table for [`vim.g`](https://neovim.io/doc/user/helptag.html?tag=vim.g).

<span class="help-syntax-special">{b}</span> `(table)` Redirection table for [`vim.b`](https://neovim.io/doc/user/helptag.html?tag=vim.b).

<span class="help-syntax-special">{w}</span> `(table)` Redirection table for [`vim.w`](https://neovim.io/doc/user/helptag.html?tag=vim.w).

<span class="help-syntax-special">{t}</span> `(table)` Redirection table for [`vim.t`](https://neovim.io/doc/user/helptag.html?tag=vim.t).

<span class="help-syntax-special">{v}</span> `(table)` Redirection table for [`vim.v`](https://neovim.io/doc/user/helptag.html?tag=vim.v).

<span class="help-syntax-special">{env}</span> `(table)` Redirection table for [`vim.env`](https://neovim.io/doc/user/helptag.html?tag=vim.env).


<span class="help-syntax-special">{o}</span> `(table)` Redirection table for [`vim.o`](https://neovim.io/doc/user/helptag.html?tag=vim.o).

<span class="help-syntax-special">{go}</span> `(table)` Redirection table for [`vim.go`](https://neovim.io/doc/user/helptag.html?tag=vim.go).

<span class="help-syntax-special">{bo}</span> `(table)` Redirection table for [`vim.bo`](https://neovim.io/doc/user/helptag.html?tag=vim.bo).

<span class="help-syntax-special">{wo}</span> `(table)` Redirection table for [`vim.wo`](https://neovim.io/doc/user/helptag.html?tag=vim.wo).

---

### Child neovim start() {#minitest-child-neovim-start}

<p align="center">`child.start`(<span class="help-syntax-special">{args}</span>, <span class="help-syntax-special">{opts}</span>)</p>

Start child process and connect to it. Won't work if child is already running.

#### Parameters {#minitest-child-neovim-start-parameters}



<span class="help-syntax-special">{args}</span> `(table)` Array with arguments for executable. Will be prepended with
  the following default arguments (see [`startup-options`](https://neovim.io/doc/user/helptag.html?tag=startup-options)):

  ```lua
  { '--clean', '-n', '--listen', <some address>,
    '--headless', '--cmd', 'set lines=24 columns=80' }
  ```


<span class="help-syntax-special">{opts}</span> `(table|nil)` Options:

  - <span class="help-syntax-keys">\<nvim_executable\></span> - name of Neovim executable. Default: [`v:progpath`](https://neovim.io/doc/user/helptag.html?tag=v:progpath).

  - <span class="help-syntax-keys">\<connection_timeout\></span> - stop trying to connect after this amount of
    milliseconds. Default: 5000.

#### Usage {#minitest-child-neovim-start-usage}



  ```lua
  child = MiniTest.new_child_neovim()

  -- Start default clean Neovim instance
  child.start()

  -- Start with custom 'init.lua' file
  child.start({ '-u', 'scripts/minimal_init.lua' })
  ```

---

### Child neovim type_keys() {#minitest-child-neovim-type_keys}

<p align="center">`child.type_keys`(<span class="help-syntax-special">{wait}</span>, <span class="help-syntax-special">{...}</span>)</p>

Basically a wrapper for [`nvim_input()`](https://neovim.io/doc/user/helptag.html?tag=nvim_input\(\)) applied inside child process.
Differences:

- Can wait after each group of characters.

- Raises error if typing keys resulted into error in child process (i.e. its
  [`v:errmsg`](https://neovim.io/doc/user/helptag.html?tag=v:errmsg) was updated).

- Key '<' as separate entry may not be escaped as '<span class="help-syntax-keys">\<LT\></span>'.

#### Parameters {#minitest-child-neovim-type_keys-parameters}



<span class="help-syntax-special">{wait}</span> `(number|nil)` Number of milliseconds to wait after each entry. May be
  omitted, in which case no waiting is done.

<span class="help-syntax-special">{...}</span> `(string|table<number,string>)` Separate entries for [`nvim_input()`](https://neovim.io/doc/user/helptag.html?tag=nvim_input\(\)),
  after which `wait` will be applied. Can be either string or array of strings.

#### Usage {#minitest-child-neovim-type_keys-usage}



  ```lua
  -- All of these type keys 'c', 'a', 'w'
  child.type_keys('caw')
  child.type_keys('c', 'a', 'w')
  child.type_keys('c', { 'a', 'w' })

  -- Waits 5 ms after `c` and after 'w'
  child.type_keys(5, 'c', { 'a', 'w' })

  -- Special keys can also be used
  child.type_keys('i', 'Hello world', '<Esc>')
  ```

---

### Child neovim get_screenshot() {#minitest-child-neovim-get_screenshot}

<p align="center">`child.get_screenshot`(<span class="help-syntax-special">{opts}</span>)</p>

Compute what is displayed on (default TUI) screen and how it is displayed.
This basically calls [`screenstring()`](https://neovim.io/doc/user/helptag.html?tag=screenstring\(\)) and [`screenattr()`](https://neovim.io/doc/user/helptag.html?tag=screenattr\(\)) for every visible
cell (row from 1 to 'lines', column from 1 to 'columns').

Notes:

- To make output more portable and visually useful, outputs of
  `screenattr()` are coded with single character symbols. Those are taken from
  94 characters (ASCII codes between 33 and 126), so there will be duplicates
  in case of more than 94 different ways text is displayed on screen.

#### Parameters {#minitest-child-neovim-get_screenshot-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possieble fields:

  - <span class="help-syntax-keys">\<redraw\></span> `(boolean)` - whether to call [`:redraw`](https://neovim.io/doc/user/helptag.html?tag=:redraw) prior to computing
    screenshot. Default: `true`.

#### Return {#minitest-child-neovim-get_screenshot-return}


`(table|nil)` Screenshot table with the following fields:

  - <span class="help-syntax-keys">\<text\></span> - "2d array" (row-column) of single characters displayed at
    particular cells.

  - <span class="help-syntax-keys">\<attr\></span> - "2d array" (row-column) of symbols representing how text is
    displayed (basically, "coded" appearance/highlighting). They should be
    used only in relation to each other: same/different symbols for two
    cells mean same/different visual appearance. Note: there will be false
    positives if there are more than 94 different attribute values.
  It also can be used with `tostring()` to convert to single string (used
  for writing to reference file). It results into two visual parts
  (separated by empty line), for `text` and `attr`. Each part has "ruler"
  above content and line numbers for each line.
  Returns `nil` if couldn't get a reasonable screenshot.

#### Usage {#minitest-child-neovim-get_screenshot-usage}



  ```lua
  local screenshot = child.get_screenshot()

  -- Show character displayed row=3 and column=4
  print(screenshot.text[3][4])

  -- Convert to string
  tostring(screenshot)
  ```

