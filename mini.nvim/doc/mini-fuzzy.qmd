---
title: "mini.fuzzy documentation"
toc-depth: 5
---

_Generated from the `main` branch of 'mini.nvim'_

<a name="mini.fuzzy" href="mini-fuzzy.qmd#mini.fuzzy"><b>mini.fuzzy</b></a> Fuzzy matching

MIT License Copyright (c) 2021 Evgeni Chasnovski

---

### Module {#minifuzzy}

Features:

- Minimal and fast fuzzy matching algorithm which prioritizes match width.


- Functions to for common fuzzy matching operations:

    - [`MiniFuzzy.match()`](mini-fuzzy.qmd#minifuzzy.match).

    - [`MiniFuzzy.filtersort()`](mini-fuzzy.qmd#minifuzzy.filtersort).

    - [`MiniFuzzy.process_lsp_items()`](mini-fuzzy.qmd#minifuzzy.process_lsp_items).


- Generator of sorter ([`MiniFuzzy.get_telescope_sorter()`](mini-fuzzy.qmd#minifuzzy.get_telescope_sorter)) for
  [nvim-telescope/telescope.nvim](https://github.com/nvim-telescope/telescope.nvim)

#### Setup {#minifuzzy-setup}


This module doesn't need setup, but it can be done to improve usability.
Setup with `require('mini.fuzzy').setup({})` (replace `{}` with your
`config` table). It will create global Lua table `MiniFuzzy` which you can
use for scripting or manually (with `:lua MiniFuzzy.*`).

See [`MiniFuzzy.config`](mini-fuzzy.qmd#minifuzzy.config) for `config` structure and default values.

You can override runtime config settings locally to buffer inside
`vim.b.minifuzzy_config` which should have same structure as
`MiniFuzzy.config`.
See [`mini.nvim-buffer-local-config`](mini-nvim.qmd#mini.nvim-buffer-local-config) for more details.

#### Notes {#minifuzzy-notes}


1. Currently there is no explicit design to work with multibyte symbols,
   but simple examples should work.
2. Smart case is used: case insensitive if input word (which is usually a
   user input) is all lower case. Case sensitive otherwise.

---

### Algorithm {#minifuzzy-algorithm}

General design uses only width of found match and index of first letter
match. No special characters or positions (like in fzy and fzf) are used.

Given non-empty input `word` and target `candidate`:

- The goal is to find matching between `word`'s letters and letters in
  `candidate` which minimizes certain score. It is assumed that order of
  letters in `word` and those matched in `candidate` should be the same.


- Matching is represented by matched positions: an array `positions` of
  integers with length equal to number of letters in `word`. The following
  should be always true in case of a match: `candidate`'s letter at index
  `positions[i]` is letters[i]` for all valid `i`.


- Matched positions are evaluated based only on two features: their width
  (number of indexes between first and last positions) and first match
  (index of first letter match). There is a global setting `cutoff` for
  which all feature values greater than it can be considered "equally bad".


- Score of matched positions is computed with following explicit formula:
  `cutoff * min(width, cutoff) + min(first, cutoff)`. It is designed to be
  equivalent to first comparing widths (lower is better) and then comparing
  first match (lower is better). For example, if `word = 'time'`:

    - '_time' (width 4) will have a better match than 't_ime' (width 5).

    - 'time_a' (width 4, first 1) will have a better match than 'a_time'
      (width 4, first 3).


- Final matched positions are those which minimize score among all possible
  matched positions of `word` and `candidate`.

---

### setup() {#minifuzzy.setup}

<p align="center">`MiniFuzzy.setup`(<span class="help-syntax-special">{config}</span>)</p>
Module setup

#### Parameters {#minifuzzy.setup-parameters}



<span class="help-syntax-special">{config}</span> `(table|nil)` Module config table. See [`MiniFuzzy.config`](mini-fuzzy.qmd#minifuzzy.config).

#### Usage {#minifuzzy.setup-usage}



  ```lua
  require('mini.fuzzy').setup() -- use default config
  -- OR
  require('mini.fuzzy').setup({}) -- replace {} with your config table
  ```

---

### config {#minifuzzy.config}

<p align="center">`MiniFuzzy.config`</p>
#### Defaults {#minifuzzy.config-defaults}



  ```lua
  MiniFuzzy.config = {
    -- Maximum allowed value of match features (width and first match). All
    -- feature values greater than cutoff can be considered "equally bad".
    cutoff = 100,
  }
  ```

---

### match() {#minifuzzy.match}

<p align="center">`MiniFuzzy.match`(<span class="help-syntax-special">{word}</span>, <span class="help-syntax-special">{candidate}</span>)</p>
Compute match data

#### Parameters {#minifuzzy.match-parameters}



<span class="help-syntax-special">{word}</span> `(string)` Input word (usually user input).

<span class="help-syntax-special">{candidate}</span> `(string)` Target word (usually with which matching is done).

#### Return {#minifuzzy.match-return}


`(table)` Matching information:

  - <span class="help-syntax-keys">\<positions\></span> `(table|nil)` - array with letter indexes inside `candidate`
    which matched to corresponding letters in `word`. It is empty array if
    `word` is empty string and `nil` if no match.

  - <span class="help-syntax-keys">\<score\></span> `number` - positive number representing how good the match is
    (lower is better). It is `-1` if no match or word is empty string.

---

### filtersort() {#minifuzzy.filtersort}

<p align="center">`MiniFuzzy.filtersort`(<span class="help-syntax-special">{word}</span>, <span class="help-syntax-special">{candidate_array}</span>)</p>
Filter string array


- Keep only input elements which match `word`.

- Sort from best to worst matches (based on score and index in original
  array, both lower is better).

#### Parameters {#minifuzzy.filtersort-parameters}



<span class="help-syntax-special">{word}</span> `(string)` String which will be searched.

<span class="help-syntax-special">{candidate_array}</span> `(table)` Lua array of strings inside which word will be
  searched.

#### Return {#minifuzzy.filtersort-return}


`(...)` Arrays of matched candidates and their indexes in original input.

---

### process_lsp_items() {#minifuzzy.process_lsp_items}

<p align="center">`MiniFuzzy.process_lsp_items`(<span class="help-syntax-special">{items}</span>, <span class="help-syntax-special">{base}</span>)</p>
Fuzzy matching for `lsp_completion.process_items` of [`MiniCompletion.config`](mini-completion.qmd#minicompletion.config)

#### Parameters {#minifuzzy.process_lsp_items-parameters}



<span class="help-syntax-special">{items}</span> `(table)` Array with LSP 'textDocument/completion' response items.

<span class="help-syntax-special">{base}</span> `(string)` Word to complete.

#### Return {#minifuzzy.process_lsp_items-return}


`(table)` Array of items with text (`filterText` or `label`) fuzzy matching `base`.

---

### get_telescope_sorter() {#minifuzzy.get_telescope_sorter}

<p align="center">`MiniFuzzy.get_telescope_sorter`(<span class="help-syntax-special">{opts}</span>)</p>
Custom getter for `telescope.nvim` sorter

Designed as a value for file and generic sorter of 'telescope.nvim'.

#### Parameters {#minifuzzy.get_telescope_sorter-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options (currently not used).

#### Usage {#minifuzzy.get_telescope_sorter-usage}



  ```lua
  require('telescope').setup({
    defaults = {
      generic_sorter = require('mini.fuzzy').get_telescope_sorter
    }
  })
  ```

