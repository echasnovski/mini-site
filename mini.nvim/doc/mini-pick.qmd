---
title: "mini.pick documentation"
toc-depth: 5
---

_Generated from the `main` branch of 'mini.nvim'_

<a name="mini.pick" href="mini-pick.qmd#mini.pick"><b>mini.pick</b></a> Pick anything

MIT License Copyright (c) 2023 Evgeni Chasnovski

---

### Module {#minipick}

Features:


- Single window general purpose interface for picking element from any array.


- On demand toggleable preview and info views.


- Interactive query matching (filter+sort) with fast non-blocking default
  which does fuzzy matching and allows other modes ([`MiniPick.default_match()`](mini-pick.qmd#minipick.default_match)).


- Built-in pickers (see [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin)):

    - Files.

    - Pattern match (for fixed pattern or with live feedback; both allow
      file filtering via glob patterns).

    - Buffers.

    - Help tags.

    - CLI output.

    - Resume latest picker.


- [`:Pick`](mini-pick.qmd#pick) command to work with extensible [`MiniPick.registry`](mini-pick.qmd#minipick.registry).


- [`vim.ui.select()`](https://neovim.io/doc/user/helptag.html?tag=vim.ui.select\(\)) implementation. To adjust, use [`MiniPick.ui_select()`](mini-pick.qmd#minipick.ui_select)
  or save-restore `vim.ui.select` manually after calling [`MiniPick.setup()`](mini-pick.qmd#minipick.setup).


- Rich and customizable built-in [`MiniPick-actions`](mini-pick.qmd#minipick-actions) when picker is active:

    - Manually change currently focused item.

    - Scroll vertically and horizontally.

    - Toggle preview or info view.

    - Mark/unmark items to choose later.

    - Refine current matches (make them part of a new picker).

    - And many more.


- Minimal yet flexible [`MiniPick-source`](mini-pick.qmd#minipick-source) specification with:

    - Items (array, callable, or manually set later).

    - Source name.

    - Working directory.

    - Matching algorithm.

    - Way matches are shown in main window.

    - Item preview.

    - "On choice" action for current and marked items.


- Custom actions/keys can be configured globally, per buffer, or per picker.


- Out of the box support for 'ignorecase' and 'smartcase'.


- Match caching to increase responsiveness on repeated prompts.

Notes:

- Works on all supported versions but Neovim>=0.10 will give more visual
  feedback in floating window footer.


- For more pickers see [`MiniExtra.pickers`](mini-extra.qmd#miniextra.pickers).

Sources with more details:

- [`MiniPick-overview`](mini-pick.qmd#minipick-overview)

- [`MiniPick-source`](mini-pick.qmd#minipick-source)

- [`MiniPick-actions`](mini-pick.qmd#minipick-actions)

- [`MiniPick-examples`](mini-pick.qmd#minipick-examples)

- [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin)

#### Dependencies {#minipick-dependencies}


Suggested dependencies (provide extra functionality, will work without them):


- Enabled [`mini.icons`](mini-icons.qmd#mini.icons) module to show icons near the items for actual paths.
  Falls back to 'nvim-tree/nvim-web-devicons' plugin or no icons will be used.


- <a name="minipick-cli-tools" href="mini-pick.qmd#minipick-cli-tools"><b>MiniPick-cli-tools</b></a> CLI tool(s) to power [`MiniPick.builtin.files()`](mini-pick.qmd#minipick.builtin.files),
  [`MiniPick.builtin.grep()`](mini-pick.qmd#minipick.builtin.grep), and [`MiniPick.builtin.grep_live()`](mini-pick.qmd#minipick.builtin.grep_live) built-in pickers:

    - `rg` (github.com/BurntSushi/ripgrep; enough for all three; recommended).

    - `fd` (github.com/sharkdp/fd; for `files` only).

    - `git` (github.com/git/git; enough for all three).

  Note: CLI tools are called only with basic arguments needed to get items.
  To customize the output, use their respective configuration approaches.
  Here are some examples of where to start:

    - github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#configuration-file

    - github.com/sharkdp/fd#excluding-specific-files-or-directories

    - git-scm.com/docs/gitignore

#### Setup {#minipick-setup}


This module needs a setup with `require('mini.pick').setup({})` (replace
`{}` with your `config` table). It will create global Lua table `MiniPick`
which you can use for scripting or manually (with `:lua MiniPick.*`).

See [`MiniPick.config`](mini-pick.qmd#minipick.config) for available config settings.

You can override runtime config settings locally to buffer inside
`vim.b.minipick_config` which should have same structure as `MiniPick.config`.
See [`mini.nvim-buffer-local-config`](mini-nvim.qmd#mini.nvim-buffer-local-config) for more details.

#### Comparisons {#minipick-comparisons}



- [nvim-telescope/telescope.nvim](https://github.com/nvim-telescope/telescope.nvim):

    - The main inspiration for this module, so there is significant overlap.

    - Has three (or two) window UI (prompt, matches, preview), while this
      module combines everything in one window. It allows more straightforward
      customization for unusual scenarios.

    - Default match algorithm is somewhat slow, while this module should
      match relatively lag-free for at least 100K+ items.

    - Has many built-in pickers, while this module has handful at its core
      relying on other 'mini.nvim' modules to provide more (see [`mini.extra`](mini-extra.qmd#mini.extra)).


- [ibhagwan/fzf-lua](https://github.com/ibhagwan/fzf-lua):

    - Mostly same comparison as with 'nvim-telescope/telescope.nvim'.

    - Requires [junegunn/fzf](https://github.com/junegunn/fzf) installed to
      power fuzzy matching, while this module provides built-in Lua matching.

#### Highlight groups {#minipick-highlightgroups}



- `MiniPickBorder` - window border.

- `MiniPickBorderBusy` - window border while picker is busy processing.

- `MiniPickBorderText` - non-prompt on border.

- `MiniPickCursor` - cursor during active picker (hidden by default).

- `MiniPickIconDirectory` - default icon for directory.

- `MiniPickIconFile` - default icon for file.

- `MiniPickHeader` - headers in info buffer and previews.

- `MiniPickMatchCurrent` - current matched item.

- `MiniPickMatchMarked` - marked matched items.

- `MiniPickMatchRanges` - ranges matching query elements.

- `MiniPickNormal` - basic foreground/background highlighting.

- `MiniPickPreviewLine` - target line in preview.

- `MiniPickPreviewRegion` - target region in preview.

- `MiniPickPrompt` - prompt.

- `MiniPickPromptCaret` - caret in prompt.

- `MiniPickPromptPrefix` - prefix of the prompt.

To change any highlight group, set it directly with [`nvim_set_hl()`](https://neovim.io/doc/user/helptag.html?tag=nvim_set_hl\(\)).

---

### Events {#minipick-events}

To allow user customization and integration of external tools, certain [`User`](https://neovim.io/doc/user/helptag.html?tag=User)
autocommand events are triggered under common circumstances:


- `MiniPickMatch` - just after updating query matches or setting items.

- `MiniPickStart` - just after picker has started.

- `MiniPickStop` - just before picker is stopped.

---

### Overview {#minipick-overview}

General idea is to take array of objects, display them with interactive
filter/sort/navigate/preview, and allow to choose one or more items.

#### How to start a picker {#minipick-overview-howtostartapicker}



- Use [`MiniPick.start()`](mini-pick.qmd#minipick.start) with `opts.source` defining [`MiniPick-source`](mini-pick.qmd#minipick-source).
  Example: `MiniPick.start({ source = { items = vim.fn.readdir('.') } })`


- Use any of [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin) pickers directly.
  Example: `MiniPick.builtin.files({ tool = 'git' })`


- Use [`:Pick`](mini-pick.qmd#pick) command which uses customizable pickers from [`MiniPick.registry`](mini-pick.qmd#minipick.registry).
  Example: `:Pick files tool='git'`

#### User interface {#minipick-overview-userinterface}


UI consists from a single window capable of displaying three different views:

- "Main" - where current query matches are shown.

- "Preview" - preview of current item (toggle with `<Tab>`).

- "Info" - general info about picker and its state (toggle with `<S-Tab>`).

Current prompt is displayed at the top left of the window border with vertical
line indicating caret (current input position).

Bottom part of window border displays (in Neovim>=0.10) extra visual feedback:

- Left part is a picker name.

- Right part contains information in the format

  ```
  <current index in matches> | <match count> | <marked count> / <total count>
  ```

When picker is busy (like if there are no items yet set or matching is active)
window border changes color to be `MiniPickBorderBusy` after `config.delay.busy`
milliseconds of idle time.

#### Life cycle {#minipick-overview-lifecycle}



- Type characters to filter and sort matches. It uses [`MiniPick.default_match()`](mini-pick.qmd#minipick.default_match)
  with `query` being an array of pressed characters.
  Overview of how it matches:

    - If query starts with `'`, the match is exact.

    - If query starts with `^`, the match is exact at start.

    - If query ends with `$`, the match is exact at end.

    - If query starts with `*`, the match is forced to be fuzzy.

    - Otherwise match is fuzzy.

    - Sorting is done to first minimize match width and then match start.
      Nothing more: no favoring certain places in string, etc.


- Type special keys to perform [`MiniPick-actions`](mini-pick.qmd#minipick-actions). Here are some basic ones:

    - `<C-n>` / `<Down>` moves down; `<C-p>` / `<Up>` moves up.

    - `<Left>` / `<Right>` moves prompt caret left / right.

    - `<S-Tab>` toggles information window with all available mappings.

    - `<Tab>` toggles preview.

    - `<C-x>` / `<C-a>` toggles current / all item(s) as (un)marked.

    - `<C-Space>` / `<M-Space>` makes all matches or marked items as new picker.

    - `<CR>` / `<M-CR>` chooses current/marked item(s).

    - `<Esc>` / `<C-c>` stops picker.

#### Implementation details {#minipick-overview-implementationdetails}



- Processing key typing is done via a dedicated key query process for more
  control over their side effects. As a result, regular mappings don't work
  here and picker's window needs to be current as long as it is shown.
  Changing window focus leads to automatic picker stop (after small delay).

- Any picker is non-blocking but waits to return the chosen item. Example:
  `file = MiniPick.builtin.files()` allows other actions to be executed when
  picker is shown while still assigning `file` with value of the chosen item.

---

### Source {#minipick-source}

Source is defined as a `source` field inside one of (in increasing priority):

- [`MiniPick.config`](mini-pick.qmd#minipick.config) - has global effect.

- `vim.b.minipick_config` - has buffer-local effect.

- `opts.source` in picker call - has effect for that particular call.

Example of source to choose from [`arglist`](https://neovim.io/doc/user/helptag.html?tag=arglist):

  ```lua
  { items = vim.fn.argv, name = 'Arglist' }
  ```

Note: this is mostly useful for writing pickers. Can safely skip if you
want to just use provided pickers.

#### Items {#minipick-source-items}


<a name="minipick-source.items" href="mini-pick.qmd#minipick-source.items"><b>MiniPick-source.items</b></a>

`source.items` defines items to choose from. It should be one of the following:

- Array of objects which can have different types. Any type is allowed.

- `nil`. Picker waits for explicit [`MiniPick.set_picker_items()`](mini-pick.qmd#minipick.set_picker_items) call.

- Callable returning any of the previous types. Will be called once on start
  with source's `cwd` set as [`current-directory`](https://neovim.io/doc/user/helptag.html?tag=current-directory).

<a name="minipick-source.items-stritems" href="mini-pick.qmd#minipick-source.items-stritems"><b>MiniPick-source.items-stritems</b></a>
Matching is done for items array based on the string representation of its
elements (here called "stritems"). For single item it is computed as follows:

- Callable is called once with output used in next steps.

- String item is used as is.

- String <span class="help-syntax-keys">\<text\></span> field of table item is used (if present).

- Use output of [`vim.inspect()`](https://neovim.io/doc/user/helptag.html?tag=vim.inspect\(\)).

Example:

  ```lua
  items = { 'aaa.txt', { text = 'bbb' }, function() return 'ccc' end }
  -- corresponding stritems are { 'aaa.txt', 'bbb', 'ccc' }
  ```

Default value is `nil`, assuming it always be supplied by the caller.

<a name="minipick-source.items-common" href="mini-pick.qmd#minipick-source.items-common"><b>MiniPick-source.items-common</b></a>
There are some recommendations for common item types in order for them to work
out of the box with [`MiniPick.default_show()`](mini-pick.qmd#minipick.default_show), [`MiniPick.default_preview()`](mini-pick.qmd#minipick.default_preview),
[`MiniPick.default_choose()`](mini-pick.qmd#minipick.default_choose), [`MiniPick.default_choose_marked()`](mini-pick.qmd#minipick.default_choose_marked):


- Path (file or directory). Use string or `path` field of a table. Path can
  be either absolute, relative to the `source.cwd`, or have a general URI format
  (only if supplied as table field).
  Examples: `'aaa.txt'`, `{ path = 'aaa.txt' }`


- Buffer. Use buffer id as number, string, or `bufnr` / `buf_id` / `buf`
  field of a table (any name is allowed).
  Examples: `1`, `'1'`, `{ bufnr = 1 }`, `{ buf_id = 1 }`, `{ buf = 1 }`


- Line in file or buffer. Use table representation with `lnum` field with line
  number (starting from 1) or string in "<span class="help-syntax-keys">\<path\></span>\0<span class="help-syntax-keys">\<line\></span>" format (`\0` is
  an actual null character; don't escape the slash; may need to be `\000`).
  Examples:

    ```lua
    { path = 'aaa.txt', lnum = 2 }, 'aaa.txt\0002', { bufnr = 1, lnum = 3 }
    ```


- Position in file or buffer. Use table representation with `lnum` and `col`
  fields with line and column numbers (starting from 1) or string in
  "<span class="help-syntax-keys">\<path\></span>\0<span class="help-syntax-keys">\<line\></span>\0<span class="help-syntax-keys">\<col\></span>" format (`\0` is an actual null character, don't
  escape the slash; may need to be `\000`).
  Examples:

    ```lua
    { path = 'aaa.txt', lnum = 2, col = 3 }, 'aaa.txt\0' .. '2\0003',
    { bufnr = 1, lnum = 3, col = 4 }
    ```


- Region in file or buffer. Use table representation with `lnum`, `col`,
  `end_lnum`, `end_col` fields for start and end line/column. All numbers
  start from 1, end line is inclusive, end column is exclusive.
  This naming is similar to [`getqflist()`](https://neovim.io/doc/user/helptag.html?tag=getqflist\(\)) and [`diagnostic-structure`](https://neovim.io/doc/user/helptag.html?tag=diagnostic-structure).
  Examples:

    ```lua
    { path = 'aaa.txt', lnum = 2, col = 3, end_lnum = 4, end_col = 5 },
    { bufnr = 1, lnum = 3, col = 4, end_lnum = 5, end_col = 6 }
    ```

Note: all table items will benefit from having `text` field for better matching.

#### Name {#minipick-source-name}


<a name="minipick-source.name" href="mini-pick.qmd#minipick-source.name"><b>MiniPick-source.name</b></a>

`source.name` defines the name of the picker to be used for visual feedback.

Default value is "<No name>".

#### Current working directory {#minipick-source-currentworkingdirectory}


<a name="minipick-source.cwd" href="mini-pick.qmd#minipick-source.cwd"><b>MiniPick-source.cwd</b></a>

`source.cwd` is a string defining the current working directory in which
picker operates. It should point to a valid actually present directory path.
This is a part of source to allow persistent way to use relative paths,
i.e. not depend on current directory being constant after picker start.
It also makes the [`MiniPick.builtin.resume()`](mini-pick.qmd#minipick.builtin.resume) picker more robust.

It will be set as local [`current-directory`](https://neovim.io/doc/user/helptag.html?tag=current-directory) ([`:lcd`](https://neovim.io/doc/user/helptag.html?tag=:lcd)) of picker's main window
to allow simpler code for "in window" functions (choose/preview/custom/etc.).

Default value is [`current-directory`](https://neovim.io/doc/user/helptag.html?tag=current-directory).

#### Match {#minipick-source-match}


<a name="minipick-source.match" href="mini-pick.qmd#minipick-source.match"><b>MiniPick-source.match</b></a>

`source.match` is a callable defining how stritems
(see [`MiniPick-source.items-stritems`](mini-pick.qmd#minipick-source.items-stritems)) are matched (filtered and sorted) based
on the query.

It will be called with the following arguments:

- `stritems` - all available stritems for current picker.

- `inds` - array of `stritems` indexes usually pointing at current matches.
  It does point to current matches in the case of interactively appending
  character at the end of the query. It assumes that matches for such bigger
  query is a subset of previous matches (implementation can ignore it).
  This can be utilized to increase performance by checking fewer stritems.

- `query` - array of strings. Usually (like is common case of user interactively
  typing query) each string represents one character. However, any strings are
  allowed, as query can be set with [`MiniPick.set_picker_query()`](mini-pick.qmd#minipick.set_picker_query).

It should either return array of match indexes for stritems elements matching
the query (synchronous) or explicitly use [`MiniPick.set_picker_match_inds()`](mini-pick.qmd#minipick.set_picker_match_inds)
to set them (may be asynchronous).

Notes:

- The result can be any array of `stritems` indexes, i.e. not necessarily
  a subset of input `inds`.


- Both `stritems` and `query` depend on values of 'ignorecase' and 'smartcase'.
  If query shows "ignore case" properties (only 'ignorecase' is set or both
  'ignorecase' / 'smartcase' are set and query has only lowercase characters),
  then `stritems` and `query` will have only lowercase characters.
  This allows automatic support for case insensitive matching while being
  faster and having simpler match function implementation.


- Writing custom `source.match` usually means also changing [`MiniPick-source.show`](mini-pick.qmd#minipick-source.show)
  because it is used to highlight stritems parts actually matching the query.

Example of simple "exact" `match()` preserving initial order:

  ```lua
  local match_exact = function(stritems, inds, query)
    local prompt_pattern = vim.pesc(table.concat(query))
    local f = function(i) return stritems[i]:find(prompt_pattern) ~= nil end
    return vim.tbl_filter(f, inds)
  end
  -- For non-blocking version see `:h MiniPick.poke_is_picker_active()`
  ```

Default value is [`MiniPick.default_match()`](mini-pick.qmd#minipick.default_match).

#### Show {#minipick-source-show}


<a name="minipick-source.show" href="mini-pick.qmd#minipick-source.show"><b>MiniPick-source.show</b></a>

`source.show` is a callable defining how matched items are shown in the window.

It will be called with the following arguments:

- `buf_id` - identifier of the target buffer.

- `items_to_show` - array of actual items to be shown in `buf_id`. This is
  a subset of currently matched items computed to fit in current window view.

- `query` - array of strings. Same as in `source.match`.

It should update buffer `buf_id` to visually represent `items_to_show`
__one item per line starting from line one__ (it shouldn't depend on
`options.content_from_bottom`). This also includes possible visualization
of which parts of stritem actually matched query.

Example (assuming string items; without highlighting):

  ```lua
  local show_prepend = function(buf_id, items_arr, query)
    local lines = vim.tbl_map(function(x) return 'Item: ' .. x end, items_arr)
    vim.api.nvim_buf_set_lines(buf_id, 0, -1, false, lines)
  end
  ```

Default value is [`MiniPick.default_show()`](mini-pick.qmd#minipick.default_show).

#### Preview {#minipick-source-preview}


<a name="minipick-source.preview" href="mini-pick.qmd#minipick-source.preview"><b>MiniPick-source.preview</b></a>

`source.preview` is a callable defining how item preview is done.

It will be called with the following arguments:

- `buf_id` - identifier of the target buffer. Note: for every separate instance
  of item previewing new scratch buffer is be created.

- `item` - item to preview.

It should update buffer `buf_id` to visually represent `item`.

Example:

  ```lua
  local preview_inspect = function(buf_id, item)
    local lines = vim.split(vim.inspect(item), '\n')
    vim.api.nvim_buf_set_lines(buf_id, 0, -1, false, lines)
  end
  ```

Default value is [`MiniPick.default_preview()`](mini-pick.qmd#minipick.default_preview).

#### Choose an item {#minipick-source-chooseanitem}


<a name="minipick-source.choose" href="mini-pick.qmd#minipick-source.choose"><b>MiniPick-source.choose</b></a>

`source.choose` is a callable defining what to do when an item is chosen.

It will be called with the following arguments:

- `item` - chosen item. Always non-`nil`.

It should perform any intended "choose" action for an item and return
a value indicating whether picker should continue (i.e. not stop):
`nil` and `false` will stop picker, other values will continue.

Notes:

- It is called when picker window is still current. Use `windows.target` value
  from [`MiniPick.get_picker_state()`](mini-pick.qmd#minipick.get_picker_state) output to do something with target window.

Example:

  ```lua
  local choose_file_continue = function(item)
    if vim.fn.filereadable(item) == 0 then return end
    vim.api.nvim_win_call(
      MiniPick.get_picker_state().windows.main,
      function() vim.cmd('edit ' .. item) end
    )
    return true
  end
  ```

Default value is [`MiniPick.default_choose()`](mini-pick.qmd#minipick.default_choose).

#### Choose marked items {#minipick-source-choosemarkeditems}


<a name="minipick-source.choose_marked" href="mini-pick.qmd#minipick-source.choose_marked"><b>MiniPick-source.choose_marked</b></a>

`source.choose_marked` is a callable defining what to do when marked items
(see [`MiniPick-actions-mark`](mini-pick.qmd#minipick-actions-mark)) are chosen. Serves as a companion to
`source.choose` which can choose several items.

It will be called with the following arguments:

- `items_marked` - array of marked items. Can be empty.

It should perform any intended "choose" action for several items and return
a value indicating whether picker should continue (i.e. not stop):
`nil` and `false` will stop picker, other values will continue.

Notes:

- It is called when picker window is still current. Use `windows.target` value
  from [`MiniPick.get_picker_state()`](mini-pick.qmd#minipick.get_picker_state) output to do something with target window.

Example:

  ```lua
  local choose_marked_print = function(items) print(vim.inspect(items)) end
  ```

Default value is [`MiniPick.default_choose_marked()`](mini-pick.qmd#minipick.default_choose_marked).

---

### Actions {#minipick-actions}

When picker is active, `mappings` table defines a set of special keys which when
pressed will execute certain actions. Those can be of two types:

- Built-in: actions present in default `config.mappings`. Can be only overridden
  with a different key.

- Custom: user defined actions. Should be a table with `char` and `func` fields.


#### Built-in {#minipick-actions-built-in}


##### Caret {#minipick-actions-built-in-caret}


<a name="minipick-actions-caret" href="mini-pick.qmd#minipick-actions-caret"><b>MiniPick-actions-caret</b></a>

User can add character not only at query end, but more generally at caret.


- `mappings.caret_left` - move caret to left.

- `mappings.caret_right` - move caret to right.

##### Choose {#minipick-actions-built-in-choose}


<a name="minipick-actions-choose" href="mini-pick.qmd#minipick-actions-choose"><b>MiniPick-actions-choose</b></a>

Choose is a fundamental action that actually implements the intent of
calling a picker, i.e. pick an item.


- `mappings.choose` - choose as is, i.e. apply `source.choose` for current item.

- `mappings.choose_in_split` - make horizontal split at target window, update
  target window to the new split, and choose.

- `mappings.choose_in_tabpage` - same as `choose_in_split`, but create tabpage.

- `mappings.choose_in_vsplit` - same as `choose_in_split`, but split vertically.

- `mappings.choose_marked` - choose marked items as is, i.e.
  apply `source.choose_marked` at current marked items.

##### Delete {#minipick-actions-built-in-delete}


<a name="minipick-actions-delete" href="mini-pick.qmd#minipick-actions-delete"><b>MiniPick-actions-delete</b></a>

Delete actions are for deleting elements from query.


- `mappings.delete_char` - delete one character to the left.

- `mappings.delete_char_right` - delete one character to the right.

- `mappings.delete_left` - delete everything to the left (like [`i_CTRL-U`](https://neovim.io/doc/user/helptag.html?tag=i_CTRL-U)).

- `mappings.delete_word` - delete word to the left (like [`i_CTRL-W`](https://neovim.io/doc/user/helptag.html?tag=i_CTRL-W)).

##### Mark {#minipick-actions-built-in-mark}


<a name="minipick-actions-mark" href="mini-pick.qmd#minipick-actions-mark"><b>MiniPick-actions-mark</b></a>

Marking is an action of adding certain items to a separate list which then can
be chosen with `mappings.choose_marked` (for example, sent to quickfix list).
This is a companion to a regular choosing which can pick only one item.


- `mappings.mark` - toggle marked/unmarked state of current item.

- `mappings.mark_all` - toggle marked/unmarked state (mark all if not all
  marked; unmark all otherwise) of all currently matched items.

Notes:

- Marks persist across queries and matches. For example, user can make a query
  with marking all matches several times and marked items from all queries
  will be preserved.

##### Move {#minipick-actions-built-in-move}


<a name="minipick-actions-move" href="mini-pick.qmd#minipick-actions-move"><b>MiniPick-actions-move</b></a>

Move is a fundamental action of changing which item is current.


- `mappings.move_down` - change focus to the item below.

- `mappings.move_start` change focus to the first currently matched item

- `mappings.move_up` - change focus to the item above.

Notes:

- Up and down wrap around edges: `move_down` on last item moves to first,
  `move_up` on first moves to last.

- Moving when preview or info view is shown updates the view with new item.

- These also work with non-overridable alternatives:

    - `<Down>` moves down.

    - `<Home>` moves to first matched.

    - `<Up>` moves up.

##### Paste {#minipick-actions-built-in-paste}


<a name="minipick-actions-paste" href="mini-pick.qmd#minipick-actions-paste"><b>MiniPick-actions-paste</b></a>

Paste is an action to paste content of [`registers`](https://neovim.io/doc/user/helptag.html?tag=registers) at caret.


- `mappings.paste` - paste from register defined by the next key press.

Notes:

- Does not support expression register `=`.

- Supports special cases of register: <span class="help-syntax-keys">\<C-f\></span> (as [`c_CTRL-R_CTRL-F`](https://neovim.io/doc/user/helptag.html?tag=c_CTRL-R_CTRL-F)),
  <span class="help-syntax-keys">\<C-w\></span> (as [`c_CTRL-R_CTRL-W`](https://neovim.io/doc/user/helptag.html?tag=c_CTRL-R_CTRL-W)), <span class="help-syntax-keys">\<C-a\></span> (as [`c_CTRL-R_CTRL-A`](https://neovim.io/doc/user/helptag.html?tag=c_CTRL-R_CTRL-A)),
  <span class="help-syntax-keys">\<C-l\></span> (as [`c_CTRL-R_CTRL-L`](https://neovim.io/doc/user/helptag.html?tag=c_CTRL-R_CTRL-L)).

##### Refine {#minipick-actions-built-in-refine}


<a name="minipick-actions-refine" href="mini-pick.qmd#minipick-actions-refine"><b>MiniPick-actions-refine</b></a>

Refine is an action that primarily executes the following:

- Takes certain items and makes them be all items (in order they are present).

- Resets query.

- Updates `source.match` to be the one from config.


- `mappings.refine` - refine currently matched items.

- `mappings.refine_marked` - refine currently marked items.

This action is useful in at least two cases:

- Perform consecutive "narrowing" queries. Example: to get items that contain
  both "hello" and "world" exact matches (in no particular order) with default
  matching, type "'hello" (notice "'" at the start) followed by `<C-Space>` and
  another "'world".

- Reset `match` to default. Particularly useful in [`MiniPick.builtin.grep_live()`](mini-pick.qmd#minipick.builtin.grep_live).

##### Scroll {#minipick-actions-built-in-scroll}


<a name="minipick-actions-scroll" href="mini-pick.qmd#minipick-actions-scroll"><b>MiniPick-actions-scroll</b></a>

Scroll is an action to either move current item focus further than to the
neighbor item or adjust window view to see more information.


- `mappings.scroll_down` - when matches are shown, go down by the amount of
  visible matches. In preview and info view - scroll down as with [`CTRL-F`](https://neovim.io/doc/user/helptag.html?tag=CTRL-F).

- `mappings.scroll_left` - scroll left as with [`zH`](https://neovim.io/doc/user/helptag.html?tag=zH).

- `mappings.scroll_right` - scroll right as with [`zL`](https://neovim.io/doc/user/helptag.html?tag=zL).

- `mappings.scroll_up` - when matches are shown, go up by the amount of
  visible matches. In preview and info view - scroll up as with [`CTRL-B`](https://neovim.io/doc/user/helptag.html?tag=CTRL-B).

##### Stop {#minipick-actions-built-in-stop}


<a name="minipick-actions-stop" href="mini-pick.qmd#minipick-actions-stop"><b>MiniPick-actions-stop</b></a>

`mappings.stop` stops the picker. <span class="help-syntax-keys">\<C-c\></span> also always stops the picker.


##### Toggle {#minipick-actions-built-in-toggle}


<a name="minipick-actions-toggle" href="mini-pick.qmd#minipick-actions-toggle"><b>MiniPick-actions-toggle</b></a>

Toggle action is a way to change view: show if target is not shown, reset to
main view otherwise.


- `mappings.toggle_info` - toggle info view.

- `mappings.toggle_preview` - toggle preview.

Note:

- Updating query in any way resets window view to show matches.

- Moving current item focus keeps preview or info view with updated item.

#### Custom {#minipick-actions-custom}


<a name="minipick-actions-custom" href="mini-pick.qmd#minipick-actions-custom"><b>MiniPick-actions-custom</b></a>

Along with built-in actions, users can define custom actions. This can be
done by supplying custom elements to `mappings` table. The field defines action
name (used to infer an action description in info view). The value is a table
with the following fields:

- <span class="help-syntax-keys">\<char\></span> `(string)` - single character acting as action trigger.

- <span class="help-syntax-keys">\<func\></span> `(function)` - callable to be executed without arguments after
  user presses <span class="help-syntax-keys">\<char\></span>. Its return value is treated as "should stop picker
  after execution", i.e. returning nothing, `nil`, or `false` continues
  picker while everything else (prefer `true`) stops it.

Example of `execute` custom mapping:

  ```lua
  execute = {
    char = '<C-e>',
    func = function() vim.cmd(vim.fn.input('Execute: ')) end,
  }
  ```

---

### Examples {#minipick-examples}

#### Disable icons {#minipick-examples-disableicons}


Disable icons in [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin) pickers related to paths:

  ```lua
  local pick = require('mini.pick')
  pick.setup({ source = { show = pick.default_show } })
  ```

#### Switch toggle and move keys {#minipick-examples-switchtoggleandmovekeys}



  ```lua
  require('mini.pick').setup({
    mappings = {
      toggle_info    = '<C-k>',
      toggle_preview = '<C-p>',
      move_down      = '<Tab>',
      move_up        = '<S-Tab>',
    }
  })
  ```

#### Different window styles: {#minipick-examples-differentwindowstyles}



  ```lua
  -- Different border
  { window = { config = { border = 'double' } } }

  -- "Cursor tooltip"
  {
    window = {
      config = {
        relative = 'cursor', anchor = 'NW',
        row = 0, col = 0, width = 40, height = 20,
      },
    },
  }

  -- Centered on screen
  local win_config = function()
    local height = math.floor(0.618 * vim.o.lines)
    local width = math.floor(0.618 * vim.o.columns)
    return {
      anchor = 'NW', height = height, width = width,
      row = math.floor(0.5 * (vim.o.lines - height)),
      col = math.floor(0.5 * (vim.o.columns - width)),
    }
  end
  { window = { config = win_config } }
  ```

---

### setup() {#minipick.setup}

<p align="center">`MiniPick.setup`(<span class="help-syntax-special">{config}</span>)</p>
Module setup

#### :Pick {#minipick.setup-pick}


<a name="pick" href="mini-pick.qmd#pick"><b>:Pick</b></a>

Calling this function creates a `:Pick` user command. It takes picker name
from [`MiniPick.registry`](mini-pick.qmd#minipick.registry) as mandatory first argument and executes it with
following (expanded, [`expandcmd()`](https://neovim.io/doc/user/helptag.html?tag=expandcmd\(\))) [`<f-args>`](https://neovim.io/doc/user/helptag.html?tag=<f-args>) combined in a single table.
To add custom pickers, update [`MiniPick.registry`](mini-pick.qmd#minipick.registry).

Example:

  ```vim
  :Pick files tool='git'
  :Pick grep pattern='<cword>'
  ```


It also sets custom [`vim.ui.select()`](https://neovim.io/doc/user/helptag.html?tag=vim.ui.select\(\)) implementation to use the module.
See [`MiniPick.ui_select()`](mini-pick.qmd#minipick.ui_select).

#### Parameters {#minipick.setup-parameters}



<span class="help-syntax-special">{config}</span> `(table|nil)` Module config table. See [`MiniPick.config`](mini-pick.qmd#minipick.config).

#### Usage {#minipick.setup-usage}



  ```lua
  require('mini.pick').setup() -- use default config
  -- OR
  require('mini.pick').setup({}) -- replace {} with your config table
  ```

---

### config {#minipick.config}

<p align="center">`MiniPick.config`</p>
#### Defaults {#minipick.config-defaults}



  ```lua
  MiniPick.config = {
    -- Delays (in ms; should be at least 1)
    delay = {
      -- Delay between forcing asynchronous behavior
      async = 10,

      -- Delay between computation start and visual feedback about it
      busy = 50,
    },

    -- Keys for performing actions. See `:h MiniPick-actions`.
    mappings = {
      caret_left  = '<Left>',
      caret_right = '<Right>',

      choose            = '<CR>',
      choose_in_split   = '<C-s>',
      choose_in_tabpage = '<C-t>',
      choose_in_vsplit  = '<C-v>',
      choose_marked     = '<M-CR>',

      delete_char       = '<BS>',
      delete_char_right = '<Del>',
      delete_left       = '<C-u>',
      delete_word       = '<C-w>',

      mark     = '<C-x>',
      mark_all = '<C-a>',

      move_down  = '<C-n>',
      move_start = '<C-g>',
      move_up    = '<C-p>',

      paste = '<C-r>',

      refine        = '<C-Space>',
      refine_marked = '<M-Space>',

      scroll_down  = '<C-f>',
      scroll_left  = '<C-h>',
      scroll_right = '<C-l>',
      scroll_up    = '<C-b>',

      stop = '<Esc>',

      toggle_info    = '<S-Tab>',
      toggle_preview = '<Tab>',
    },

    -- General options
    options = {
      -- Whether to show content from bottom to top
      content_from_bottom = false,

      -- Whether to cache matches (more speed and memory on repeated prompts)
      use_cache = false,
    },

    -- Source definition. See `:h MiniPick-source`.
    source = {
      items = nil,
      name  = nil,
      cwd   = nil,

      match   = nil,
      show    = nil,
      preview = nil,

      choose        = nil,
      choose_marked = nil,
    },

    -- Window related options
    window = {
      -- Float window config (table or callable returning it)
      config = nil,

      -- String to use as caret in prompt
      prompt_caret = '▏',

      -- String to use as prefix in prompt
      prompt_prefix = '> ',
    },
  }
  ```

#### Delays {#minipick.config-delays}


`config.delay` defines plugin delays (in ms). All should be strictly positive.

`delay.async` is a delay between forcing asynchronous behavior. This usually
means making screen redraws and utilizing [`MiniPick.poke_is_picker_active()`](mini-pick.qmd#minipick.poke_is_picker_active)
(for example, to stop current matching if query has updated).
Smaller values give smoother user experience at the cost of more computations.

`delay.busy` is a delay between when some computation starts and showing
visual feedback about it by making window border to have `MiniPickBorderBusy`
highlight group.
Smaller values will give feedback faster at the cost of feeling like flicker.

#### Mappings {#minipick.config-mappings}


`config.mappings` defines keys for special actions to be triggered after certain
keys. See [`MiniPick-actions`](mini-pick.qmd#minipick-actions) for more information.

#### Options {#minipick.config-options}


`config.options` contains some general purpose options.

`options.content_from_bottom` is a boolean indicating whether content should be
shown from bottom to top. That means that best matches will be shown at
the bottom. Note: for better experience use Neovim>=0.10, which has floating
window footer capability. Default: `false`.

`options.use_cache` is a boolean indicating whether match results should be
cached per prompt (i.e. concatenated query). This results into faster response
on repeated prompts (like when deleting query entries) at the cost of using
more memory. Default: `false`.

#### Source {#minipick.config-source}


`config.source` defines fallbacks for source specification. For example, this
can be used to change default `match` to use different implementation or `show`
to not show icons for some [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin) pickers (see [`MiniPick-examples`](mini-pick.qmd#minipick-examples)).
See [`MiniPick-source`](mini-pick.qmd#minipick-source) for more information.

#### Window {#minipick.config-window}


`config.window` contains window specific configurations.

`window.config` defines a (parts of) default floating window config for the main
picker window. This can be either a table overriding some parts or a callable
returning such table. See [`MiniPick-examples`](mini-pick.qmd#minipick-examples) for some examples.

`window.prompt_caret` defines how caret is displayed in window's prompt.
Default: '▏'.

`window.prompt_prefix` defines what prefix is used in window's prompt.
Default: '> '.

---

### start() {#minipick.start}

<p align="center">`MiniPick.start`(<span class="help-syntax-special">{opts}</span>)</p>
Start picker

Notes:

- If there is currently an active picker, it is properly stopped and new one
  is started "soon" in the main event-loop (see [`vim.schedule()`](https://neovim.io/doc/user/helptag.html?tag=vim.schedule\(\))).

- Current window at the moment of this function call is treated as "target".
  It will be set back as current after [`MiniPick.stop()`](mini-pick.qmd#minipick.stop).
  See [`MiniPick.get_picker_state()`](mini-pick.qmd#minipick.get_picker_state) and [`MiniPick.set_picker_target_window()`](mini-pick.qmd#minipick.set_picker_target_window).

#### Parameters {#minipick.start-parameters}



<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Should have same structure as [`MiniPick.config`](mini-pick.qmd#minipick.config).
  Default values are inferred from there.
  Usually should have proper [`MiniPick-source.items`](mini-pick.qmd#minipick-source.items) defined.

#### Return {#minipick.start-return}


`(any)` Item which was current when picker is stopped; `nil` if aborted.

---

### stop() {#minipick.stop}

<p align="center">`MiniPick.stop`()</p>
Stop active picker

---

### refresh() {#minipick.refresh}

<p align="center">`MiniPick.refresh`()</p>
Refresh active picker

---

### default_match() {#minipick.default_match}

<p align="center">`MiniPick.default_match`(<span class="help-syntax-special">{stritems}</span>, <span class="help-syntax-special">{inds}</span>, <span class="help-syntax-special">{query}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Default match

Filter target stritems to contain query and sort from best to worst matches.

Implements default value for [`MiniPick-source.match`](mini-pick.qmd#minipick-source.match).

By default (if no special modes apply) it does the following fuzzy matching:


- Stritem contains query if it contains all its elements verbatim in the same
  order (possibly with gaps, i.e. not strictly one after another).
  Note: empty query and empty string element is contained in any string.


- Sorting is done with the following ordering (same as in [`mini.fuzzy`](mini-fuzzy.qmd#mini.fuzzy)):

    - The smaller the match width (end column minus start column) the better.

    - Among same match width, the smaller start column the better.

    - Among same match width and start column, preserve original order.

Notes:

- Most common interactive usage results into `query` containing one typed
  character per element.

#### Special modes {#minipick.default_match-specialmodes}



- Forced modes:

    - Query starts with "*": match the rest fuzzy (without other modes).

    - Query starts with "'": match the rest exactly (without gaps).


- Place modes:

    - Query starts with '^': match the rest exactly at start.

    - Query ends with '$': match the rest exactly at end.

    - Both modes can be used simultaneously.


- Grouped: query contains at least one whitespace element. Output is computed
  as if query is split at whitespace indexes with concatenation between them.

Precedence of modes:
  "forced exact" = "forced fuzzy" > "place start/end" > "grouped" > "default"

#### Examples {#minipick.default_match-examples}


Assuming `stritems` are `{ '_abc', 'a_bc', 'ab_c', 'abc_' }`, here are some
example matches based on prompt (concatenated query):

  ```
  | Prompt | Matches                |
  |--------|------------------------|
  | abc    | All                    |
  | *abc   | All                    |
  |        |                        |
  | 'abc   | abc_, _abc             |
  | *'abc  | None (no "'" in items) |
  |        |                        |
  | ^abc   | abc_                   |
  | *^abc  | None (no "^" in items) |
  |        |                        |
  | abc$   | _abc                   |
  | *abc$  | None (no "$" in items) |
  |        |                        |
  | ab c   | abc_, _abc, ab_c       |
  | *ab c  | None (no " " in items) |
  ```

Having query `{ 'ab', 'c' }` is the same as "ab c" prompt.

You can have a feel of how this works with this command:

  ```lua
  MiniPick.start({ source = { items = { '_abc', 'a_bc', 'ab_c', 'abc_' } } })
  ```

#### Parameters {#minipick.default_match-parameters}



<span class="help-syntax-special">{stritems}</span> `(table)` Array of all stritems.

<span class="help-syntax-special">{inds}</span> `(table)` Array of `stritems` indexes to match. All of them should point
  at string elements of `stritems`. No check is done for performance reasons.

<span class="help-syntax-special">{query}</span> `(table)` Array of strings.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<sync\></span> `(boolean)` - Whether to match synchronously. Default: `false`.

  - <span class="help-syntax-keys">\<preserve_order\></span> `(boolean)` - Whether to skip sort step. Default: `false`.

#### Return {#minipick.default_match-return}


`(table|nil)` Depending on whether computation is synchronous (either `opts.sync`
  is `true` or there is an active picker):

  - If yes, array of `stritems` indexes matching the `query` (from best to worst).

  - If no, `nil` is returned with [`MiniPick.set_picker_match_inds()`](mini-pick.qmd#minipick.set_picker_match_inds) used later.

---

### default_show() {#minipick.default_show}

<p align="center">`MiniPick.default_show`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{items}</span>, <span class="help-syntax-special">{query}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Default show

Show items in a buffer and highlight parts that actually match query (assuming
match is done with [`MiniPick.default_match()`](mini-pick.qmd#minipick.default_match)). Lines are computed based on
the [`MiniPick-source.items-stritems`](mini-pick.qmd#minipick-source.items-stritems).

Implements default value for [`MiniPick-source.show`](mini-pick.qmd#minipick-source.show).

Uses the following highlight groups (see [`mini.pick`](mini-pick.qmd#mini.pick) for their description):


- `MiniPickIconDirectory`

- `MiniPickIconFile`

- `MiniPickMatchCurrent`

- `MiniPickMatchMarked`

- `MiniPickMatchRanges`

#### Parameters {#minipick.default_show-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number)` Identifier of target buffer.

<span class="help-syntax-special">{items}</span> `(table)` Array of items to show.

<span class="help-syntax-special">{query}</span> `(table)` Array of strings representing query.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<show_icons\></span> `(boolean)` - whether to show icons for entries recognized as
    valid actually present paths on disk (see [`MiniPick-source.items-common`](mini-pick.qmd#minipick-source.items-common)),
    empty space otherwise. Tries to use `text` field as fallback for path.
    Default: `false`. Note: [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin) pickers showing file/directory
    paths use `true` by default.

  - <span class="help-syntax-keys">\<icons\></span> `(table)` - table with fallback icons used if icon provider
    does not itself supply default icons for category. Can have fields:

      - <span class="help-syntax-keys">\<directory\></span> `(string)` - icon for directory. Default: " ".

      - <span class="help-syntax-keys">\<file\></span> `(string)` - icon for file. Default: " ".

      - <span class="help-syntax-keys">\<none\></span> `(string)` - icon for non-valid path. Default: "  ".

---

### default_preview() {#minipick.default_preview}

<p align="center">`MiniPick.default_preview`(<span class="help-syntax-special">{buf_id}</span>, <span class="help-syntax-special">{item}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Default preview

Preview item. Logic follows the rules in [`MiniPick-source.items-common`](mini-pick.qmd#minipick-source.items-common):

- File and buffer are shown at the start.

- Directory has its content listed.

- Line/position/region in file or buffer is shown at start.

- Others are shown directly with [`vim.inspect()`](https://neovim.io/doc/user/helptag.html?tag=vim.inspect\(\)).

Implements default value for [`MiniPick-source.preview`](mini-pick.qmd#minipick-source.preview).

Uses the following highlight groups (see [`mini.pick`](mini-pick.qmd#mini.pick) for their description):


- `MiniPickPreviewLine`

- `MiniPickPreviewRegion`

#### Parameters {#minipick.default_preview-parameters}



<span class="help-syntax-special">{buf_id}</span> `(number)` Identifier of target buffer.

<span class="help-syntax-special">{item}</span> `(any)` Item to preview.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible values:

  - <span class="help-syntax-keys">\<n_context_lines\></span> `(number)` - number of lines to load past target position
    when reading from disk. Useful to explore context. Default: 'lines' twice.

  - <span class="help-syntax-keys">\<line_position\></span> `(string)` - where in the window to show item position.
    One of "top", "center", "bottom". Default: "top".

---

### default_choose() {#minipick.default_choose}

<p align="center">`MiniPick.default_choose`(<span class="help-syntax-special">{item}</span>)</p>
Default choose

Choose item. Logic follows the rules in [`MiniPick-source.items-common`](mini-pick.qmd#minipick-source.items-common):

- File uses [`bufadd()`](https://neovim.io/doc/user/helptag.html?tag=bufadd\(\)) and sets cursor at the start of line/position/region.

- Buffer is set as current in target window and sets cursor similarly.

- Directory is called with [`:edit`](https://neovim.io/doc/user/helptag.html?tag=:edit) in the target window.

- Others have the output of [`vim.inspect()`](https://neovim.io/doc/user/helptag.html?tag=vim.inspect\(\)) printed in Command line.

Implements default value for [`MiniPick-source.choose`](mini-pick.qmd#minipick-source.choose).

#### Parameters {#minipick.default_choose-parameters}



<span class="help-syntax-special">{item}</span> `(any)` Item to choose.

---

### default_choose_marked() {#minipick.default_choose_marked}

<p align="center">`MiniPick.default_choose_marked`(<span class="help-syntax-special">{items}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Default choose marked items

Choose marked items. Logic follows the rules in [`MiniPick-source.items-common`](mini-pick.qmd#minipick-source.items-common):

- If among items there is at least one file or buffer, quickfix list is opened
  with all file or buffer lines/positions/regions.

- Otherwise, picker's `source.choose` is called on the first item.

Implements default value for [`MiniPick-source.choose_marked`](mini-pick.qmd#minipick-source.choose_marked).

#### Parameters {#minipick.default_choose_marked-parameters}



<span class="help-syntax-special">{items}</span> `(table)` Array of items to choose.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<list_type\></span> `(string)` - which type of list to open. One of "quickfix"
    or "location". Default: "quickfix".

---

### ui_select() {#minipick.ui_select}

<p align="center">`MiniPick.ui_select`(<span class="help-syntax-special">{items}</span>, <span class="help-syntax-special">{opts}</span>, <span class="help-syntax-special">{on_choice}</span>, <span class="help-syntax-special">{start_opts}</span>)</p>
Select rewrite

Function which can be used to directly override [`vim.ui.select()`](https://neovim.io/doc/user/helptag.html?tag=vim.ui.select\(\)) to use
'mini.pick' for any "select" type of tasks.
Set automatically in [`MiniPick.setup()`](mini-pick.qmd#minipick.setup).

Implements required by `vim.ui.select()` signature, with some differencies:

- Allows `opts.preview_item` that returns an array of lines for item preview.

- Allows fourth `start_opts` argument to customize [`MiniPick.start()`](mini-pick.qmd#minipick.start) call.

Notes:

- `on_choice` is called when target window is current.

#### Usage {#minipick.ui_select-usage}



  ```lua
  -- Customize with fourth argument inside a function wrapper
  vim.ui.select = function(items, opts, on_choice)
    local start_opts = { window = { config = { width = vim.o.columns } } }
    return MiniPick.ui_select(items, opts, on_choice, start_opts)
  end
  ```

To preserve original `vim.ui.select()`:

  ```lua
  local ui_select_orig = vim.ui.select
  require('mini.pick').setup()
  vim.ui.select = ui_select_orig
  ```

---

### builtin {#minipick.builtin}

<p align="center">`MiniPick.builtin`</p>
Table with built-in pickers

---

### builtin.files() {#minipick.builtin.files}

<p align="center">`MiniPick.builtin.files`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from files

Lists all files recursively in all subdirectories. Tries to use one of the
CLI tools to create items (see [`MiniPick-cli-tools`](mini-pick.qmd#minipick-cli-tools)): `rg`, `fd`, `git`.
If none is present, uses fallback which utilizes [`vim.fs.dir()`](https://neovim.io/doc/user/helptag.html?tag=vim.fs.dir\(\)).

To customize CLI tool search, either use tool's global configuration approach
or directly [`MiniPick.builtin.cli()`](mini-pick.qmd#minipick.builtin.cli) with specific command.

#### Parameters {#minipick.builtin.files-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<tool\></span> `(string)` - which tool to use. One of "rg", "fd", "git", "fallback".
    Default: whichever tool is present, trying in that same order.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.grep() {#minipick.builtin.grep}

<p align="center">`MiniPick.builtin.grep`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from pattern matches

Lists all pattern matches recursively in all subdirectories.
Tries to use one of the CLI tools to create items (see [`MiniPick-cli-tools`](mini-pick.qmd#minipick-cli-tools)):
`rg`, `git`. If none is present, uses fallback which utilizes [`vim.fs.dir()`](https://neovim.io/doc/user/helptag.html?tag=vim.fs.dir\(\)) and
Lua pattern matches (NOT recommended in large directories).

To customize CLI tool search, either use tool's global configuration approach
or directly [`MiniPick.builtin.cli()`](mini-pick.qmd#minipick.builtin.cli) with specific command.

#### Parameters {#minipick.builtin.grep-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<tool\></span> `(string)` - which tool to use. One of "rg", "git", "fallback".
    Default: whichever tool is present, trying in that same order.

  - <span class="help-syntax-keys">\<pattern\></span> `(string)` - string pattern to search. If not given, asks user
    interactively with [`input()`](https://neovim.io/doc/user/helptag.html?tag=input\(\)).

  - <span class="help-syntax-keys">\<globs\></span> `(table)` - array of string glob patterns to restrict search to
    matching files. Supported only by "rg" and "git" tools, respects their
    specific glob syntax and effects. Default: `{}` (no restriction).
    Example: `{ '*.lua', 'lua/**' }` for Lua files and files in "lua" directory.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.grep_live() {#minipick.builtin.grep_live}

<p align="center">`MiniPick.builtin.grep_live`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from pattern matches with live feedback

Perform pattern matching treating prompt as pattern. Gives live feedback on
which matches are found. Use [`MiniPick-actions-refine`](mini-pick.qmd#minipick-actions-refine) to revert to regular
matching. Use `<C-o>` to restrict search to files matching glob patterns.
Tries to use one of the CLI tools to create items (see [`MiniPick-cli-tools`](mini-pick.qmd#minipick-cli-tools)):
`rg`, `git`. If none is present, error is thrown (for performance reasons).

To customize search, use tool's global configuration approach.

#### Parameters {#minipick.builtin.grep_live-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<tool\></span> `(string)` - which tool to use. One of "rg", "git".
    Default: whichever tool is present, trying in that same order.

  - <span class="help-syntax-keys">\<globs\></span> `(table)` - array of string glob patterns to restrict search to
    matching files. Supported only by "rg" and "git" tools, respects their
    specific glob syntax and effects. Default: `{}` (no restriction).
    Example: `{ '*.lua', 'lua/**' }` for Lua files and files in "lua" directory.
    Use `<C-o>` custom mapping to add glob to the array.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.help() {#minipick.builtin.help}

<p align="center">`MiniPick.builtin.help`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from help tags

Notes:

- On choose directly executes [`:help`](https://neovim.io/doc/user/helptag.html?tag=:help) command with appropriate modifier
  (none, [`:vertical`](https://neovim.io/doc/user/helptag.html?tag=:vertical), [`:tab`](https://neovim.io/doc/user/helptag.html?tag=:tab)). This is done through custom mappings named
  `show_help_in_{split,vsplit,tab}`. Not `choose_in_{split,vsplit,tab}` because
  there is no split guarantee (like if there is already help window opened).

#### Parameters {#minipick.builtin.help-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<default_split\></span> `(string)` - direction of a split for `choose` action.
    One of "horizontal", "vertical", "tab". Default: "horizontal".

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.buffers() {#minipick.builtin.buffers}

<p align="center">`MiniPick.builtin.buffers`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from buffers

Notes:

- There are not built-in mappings for buffer manipulation. Here is an example
  of how to call this function with mapping to wipeout the current item:

  ```lua
  local wipeout_cur = function()
    vim.api.nvim_buf_delete(MiniPick.get_picker_matches().current.bufnr, {})
  end
  local buffer_mappings = { wipeout = { char = '<C-d>', func = wipeout_cur } }
  MiniPick.builtin.buffers(local_opts, { mappings = buffer_mappings })
  ```

#### Parameters {#minipick.builtin.buffers-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<include_current\></span> `(boolean)` - whether to include current buffer in
    the output. Default: `true`.

  - <span class="help-syntax-keys">\<include_unlisted\></span> `(boolean)` - whether to include [`unlisted-buffer`](https://neovim.io/doc/user/helptag.html?tag=unlisted-buffer)s in
    the output. Default: `false`.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.cli() {#minipick.builtin.cli}

<p align="center">`MiniPick.builtin.cli`(<span class="help-syntax-special">{local_opts}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Pick from CLI output

Executes command line tool and constructs items based on its output.
Uses [`MiniPick.set_picker_items_from_cli()`](mini-pick.qmd#minipick.set_picker_items_from_cli).

Example: `MiniPick.builtin.cli({ command = { 'echo', 'a\nb\nc' } })`

#### Parameters {#minipick.builtin.cli-parameters}



<span class="help-syntax-special">{local_opts}</span> `(table|nil)` Options defining behavior of this particular picker.
  Possible fields:

  - <span class="help-syntax-keys">\<command\></span> `(table)` - forwarded to `set_picker_items_from_cli()`.

  - <span class="help-syntax-keys">\<postprocess\></span> `(function)` - forwarded to `set_picker_items_from_cli()`.

  - <span class="help-syntax-keys">\<spawn_opts\></span> `(table)` - forwarded to `set_picker_items_from_cli()`.
    Note: if `cwd` field is absent, it is inferred from [`MiniPick-source.cwd`](mini-pick.qmd#minipick-source.cwd).

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options forwarded to [`MiniPick.start()`](mini-pick.qmd#minipick.start).

---

### builtin.resume() {#minipick.builtin.resume}

<p align="center">`MiniPick.builtin.resume`()</p>
Resume latest picker

---

### registry {#minipick.registry}

<p align="center">`MiniPick.registry`</p>
Picker registry

Place for users and extensions to manage pickers with their commonly used
local options. By default contains all [`MiniPick.builtin`](mini-pick.qmd#minipick.builtin) pickers.
All entries should accept only a single `local_opts` table argument.

Serves as a source for [`:Pick`](mini-pick.qmd#pick) command.

Customization examples:

  ```lua
  -- Adding custom picker to pick `register` entries
  MiniPick.registry.registry = function()
    local items = vim.tbl_keys(MiniPick.registry)
    table.sort(items)
    local source = {items = items, name = 'Registry', choose = function() end}
    local chosen_picker_name = MiniPick.start({ source = source })
    if chosen_picker_name == nil then return end
    return MiniPick.registry[chosen_picker_name]()
  end

  -- Make `:Pick files` accept `cwd`
  MiniPick.registry.files = function(local_opts)
    local opts = { source = { cwd = local_opts.cwd } }
    local_opts.cwd = nil
    return MiniPick.builtin.files(local_opts, opts)
  end
  ```

---

### get_picker_items() {#minipick.get_picker_items}

<p align="center">`MiniPick.get_picker_items`()</p>
Get items of active picker

#### Return {#minipick.get_picker_items-return}


`(table|nil)` Picker items or `nil` if no active picker.

#### See also {#minipick.get_picker_items-seealso}


[`MiniPick.set_picker_items()`](mini-pick.qmd#minipick.set_picker_items) and [`MiniPick.set_picker_items_from_cli()`](mini-pick.qmd#minipick.set_picker_items_from_cli)

---

### get_picker_stritems() {#minipick.get_picker_stritems}

<p align="center">`MiniPick.get_picker_stritems`()</p>
Get stritems of active picker

#### Return {#minipick.get_picker_stritems-return}


`(table|nil)` Picker stritems ([`MiniPick-source.items-stritems`](mini-pick.qmd#minipick-source.items-stritems)) or `nil` if
  no active picker.

#### See also {#minipick.get_picker_stritems-seealso}


[`MiniPick.set_picker_items()`](mini-pick.qmd#minipick.set_picker_items) and [`MiniPick.set_picker_items_from_cli()`](mini-pick.qmd#minipick.set_picker_items_from_cli)

---

### get_picker_matches() {#minipick.get_picker_matches}

<p align="center">`MiniPick.get_picker_matches`()</p>
Get matches of active picker

#### Return {#minipick.get_picker_matches-return}


`(table|nil)` Picker matches or `nil` if no active picker. Matches is a table
  with the following fields:

  - <span class="help-syntax-keys">\<all\></span> `(table|nil)` - all currently matched items.

  - <span class="help-syntax-keys">\<all_inds\></span> `(table|nil)` - indexes of all currently matched items.

  - <span class="help-syntax-keys">\<current\></span> `(any)` - current matched item.

  - <span class="help-syntax-keys">\<current_ind\></span> `(number|nil)` - index of current matched item.

  - <span class="help-syntax-keys">\<marked\></span> `(table|nil)` - marked items.

  - <span class="help-syntax-keys">\<marked_inds\></span> `(table|nil)` - indexes of marked items.

  - <span class="help-syntax-keys">\<shown\></span> `(table|nil)` - shown items (from top to bottom).

  - <span class="help-syntax-keys">\<shown_inds\></span> `(table|nil)` - indexes of shown items (from top to bottom).

#### See also {#minipick.get_picker_matches-seealso}


[`MiniPick.set_picker_match_inds()`](mini-pick.qmd#minipick.set_picker_match_inds)

---

### get_picker_opts() {#minipick.get_picker_opts}

<p align="center">`MiniPick.get_picker_opts`()</p>
Get config of active picker

#### Return {#minipick.get_picker_opts-return}


`(table|nil)` Picker config (`start()`'s input `opts` table) or `nil` if
  no active picker.

#### See also {#minipick.get_picker_opts-seealso}


[`MiniPick.set_picker_opts()`](mini-pick.qmd#minipick.set_picker_opts)

---

### get_picker_state() {#minipick.get_picker_state}

<p align="center">`MiniPick.get_picker_state`()</p>
Get state data of active picker

#### Return {#minipick.get_picker_state-return}


`(table|nil)` Table with picker state data or `nil` if no active picker.
  State data is a table with the following fields:

  - <span class="help-syntax-keys">\<buffers\></span> `(table)` - table with `main`, `preview`, `info` fields representing
    buffer identifier (or `nil`) for corresponding view.

  - <span class="help-syntax-keys">\<windows\></span> `(table)` - table with `main` and `target` fields representing
    window identifiers for main and target windows.

  - <span class="help-syntax-keys">\<caret\></span> `(number)` - caret column.

  - <span class="help-syntax-keys">\<is_busy\></span> `(boolean)` - whether picker is busy with computations.

#### See also {#minipick.get_picker_state-seealso}


[`MiniPick.set_picker_target_window()`](mini-pick.qmd#minipick.set_picker_target_window)

---

### get_picker_query() {#minipick.get_picker_query}

<p align="center">`MiniPick.get_picker_query`()</p>
Get query of active picker

#### Return {#minipick.get_picker_query-return}


`(table|nil)` Array of picker query or `nil` if no active picker.

#### See also {#minipick.get_picker_query-seealso}


[`MiniPick.set_picker_query()`](mini-pick.qmd#minipick.set_picker_query)

---

### set_picker_items() {#minipick.set_picker_items}

<p align="center">`MiniPick.set_picker_items`(<span class="help-syntax-special">{items}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Set items for active picker

Note: sets items asynchronously in non-blocking fashion.

#### Parameters {#minipick.set_picker_items-parameters}



<span class="help-syntax-special">{items}</span> `(table)` Array of items.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<do_match\></span> `(boolean)` - whether to perform match after setting items.
    Default: `true`.

  - <span class="help-syntax-keys">\<querytick\></span> `(number|nil)` - value of querytick ([`MiniPick.get_querytick()`](mini-pick.qmd#minipick.get_querytick))
    to periodically check against when setting items. If checked querytick
    differs from supplied, no items are set.

#### See also {#minipick.set_picker_items-seealso}


[`MiniPick.get_picker_items()`](mini-pick.qmd#minipick.get_picker_items) and [`MiniPick.get_picker_stritems()`](mini-pick.qmd#minipick.get_picker_stritems)

---

### set_picker_items_from_cli() {#minipick.set_picker_items_from_cli}

<p align="center">`MiniPick.set_picker_items_from_cli`(<span class="help-syntax-special">{command}</span>, <span class="help-syntax-special">{opts}</span>)</p>
Set items for active picker based on CLI output

Asynchronously executes `command` and sets items to its postprocessed output.

Example:

  ```lua
  local items = vim.schedule_wrap(function()
    MiniPick.set_picker_items_from_cli({ 'echo', 'a\nb\nc' })
  end)
  MiniPick.start({ source = { items = items, name = 'Echo abc' } })
  ```

#### Parameters {#minipick.set_picker_items_from_cli-parameters}



<span class="help-syntax-special">{command}</span> `(table)` Array with (at least one) string command parts.

<span class="help-syntax-special">{opts}</span> `(table|nil)` Options. Possible fields:

  - <span class="help-syntax-keys">\<postprocess\></span> `(function)` - callable performing postprocessing of output.
    Will be called with array of lines as input, should return array of items.
    Default: removes trailing empty lines and uses rest as string items.

  - <span class="help-syntax-keys">\<spawn_opts\></span> `(table)` - `options` for [`uv.spawn()`](https://neovim.io/doc/user/helptag.html?tag=uv.spawn\(\)), except `args` and `stdio`.
    Note: relative `cwd` path is resolved against active picker's `cwd`.

  - <span class="help-syntax-keys">\<set_items_opts\></span> `(table)` - table forwarded to [`MiniPick.set_picker_items()`](mini-pick.qmd#minipick.set_picker_items).

#### See also {#minipick.set_picker_items_from_cli-seealso}


[`MiniPick.get_picker_items()`](mini-pick.qmd#minipick.get_picker_items) and [`MiniPick.get_picker_stritems()`](mini-pick.qmd#minipick.get_picker_stritems)

---

### set_picker_match_inds() {#minipick.set_picker_match_inds}

<p align="center">`MiniPick.set_picker_match_inds`(<span class="help-syntax-special">{match_inds}</span>, <span class="help-syntax-special">{match_type}</span>)</p>
Set match indexes for active picker

There are two intended use cases:

- Inside custom asynchronous [`MiniPick-source.match`](mini-pick.qmd#minipick-source.match) function to set which of
  picker's stritems match the query. See [`MiniPick.poke_is_picker_active()`](mini-pick.qmd#minipick.poke_is_picker_active).

- To programmatically set current match and marked items.
  See [`MiniPick.get_picker_matches()`](mini-pick.qmd#minipick.get_picker_matches).

#### Parameters {#minipick.set_picker_match_inds-parameters}



<span class="help-syntax-special">{match_inds}</span> `(table)` Array of numbers with picker's items indexes.

<span class="help-syntax-special">{match_type}</span> `(string|nil)` Type of match indexes to set. One of:

  - `"all"` (default) - indexes of items that match query.

  - `"current"` - index of current match. Only first element is used and should
    also be present among query matches.

  - `"marked"` - indexes of marked items. Values can be not among query matches.
    Will make only input indexes be marked, i.e. current marks are reset.
  Note: no `"shown"` match type as those indexes are computed automatically.

#### See also {#minipick.set_picker_match_inds-seealso}


[`MiniPick.get_picker_matches()`](mini-pick.qmd#minipick.get_picker_matches)

---

### set_picker_opts() {#minipick.set_picker_opts}

<p align="center">`MiniPick.set_picker_opts`(<span class="help-syntax-special">{opts}</span>)</p>
Set config for active picker

#### Parameters {#minipick.set_picker_opts-parameters}



<span class="help-syntax-special">{opts}</span> `(table)` Table overriding initial `opts` input of [`MiniPick.start()`](mini-pick.qmd#minipick.start).

#### See also {#minipick.set_picker_opts-seealso}


[`MiniPick.get_picker_opts()`](mini-pick.qmd#minipick.get_picker_opts)

---

### set_picker_target_window() {#minipick.set_picker_target_window}

<p align="center">`MiniPick.set_picker_target_window`(<span class="help-syntax-special">{win_id}</span>)</p>
Set target window for active picker

#### Parameters {#minipick.set_picker_target_window-parameters}



<span class="help-syntax-special">{win_id}</span> `(number)` Valid window identifier to be used as the new target window.

#### See also {#minipick.set_picker_target_window-seealso}


[`MiniPick.get_picker_state()`](mini-pick.qmd#minipick.get_picker_state)

---

### set_picker_query() {#minipick.set_picker_query}

<p align="center">`MiniPick.set_picker_query`(<span class="help-syntax-special">{query}</span>)</p>
Set query for active picker

#### Parameters {#minipick.set_picker_query-parameters}



<span class="help-syntax-special">{query}</span> `(table)` Array of strings to be set as the new picker query.

#### See also {#minipick.set_picker_query-seealso}


[`MiniPick.get_picker_query()`](mini-pick.qmd#minipick.get_picker_query)

---

### get_querytick() {#minipick.get_querytick}

<p align="center">`MiniPick.get_querytick`()</p>
Get query tick

Query tick is a unique query identifier. Intended to be used to detect user
activity during and between [`MiniPick.start()`](mini-pick.qmd#minipick.start) calls for efficient non-blocking
functionality. Updates after any query change, picker start and stop.

See [`MiniPick.poke_is_picker_active()`](mini-pick.qmd#minipick.poke_is_picker_active) for usage example.

#### Return {#minipick.get_querytick-return}


`(number)` Query tick.

---

### is_picker_active() {#minipick.is_picker_active}

<p align="center">`MiniPick.is_picker_active`()</p>
Check if there is an active picker

#### Return {#minipick.is_picker_active-return}


`(boolean)` Whether there is currently an active picker.

#### See also {#minipick.is_picker_active-seealso}


[`MiniPick.poke_is_picker_active()`](mini-pick.qmd#minipick.poke_is_picker_active)

---

### poke_is_picker_active() {#minipick.poke_is_picker_active}

<p align="center">`MiniPick.poke_is_picker_active`()</p>
Poke if picker is active

Intended to be used for non-blocking implementation of source methods.
Returns an output of [`MiniPick.is_picker_active()`](mini-pick.qmd#minipick.is_picker_active), but depending on
whether there is a coroutine running:

- If no, return it immediately.

- If yes, return it after `coroutine.yield()` with `coroutine.resume()`
  called "soon" by the main event-loop (see [`vim.schedule()`](https://neovim.io/doc/user/helptag.html?tag=vim.schedule\(\))).

Example of non-blocking exact `match` (as demo; can be optimized further):

  ```lua
  local match_nonblock = function(match_inds, stritems, query)
    local prompt, querytick = table.concat(query), MiniPick.get_querytick()
    local f = function()
      local res = {}
      for _, ind in ipairs(match_inds) do
        local should_stop = not MiniPick.poke_is_picker_active() or
          MiniPick.get_querytick() ~= querytick
        if should_stop then return end

        if stritems[ind]:find(prompt) ~= nil then table.insert(res, ind) end
      end

      MiniPick.set_picker_match_inds(res)
    end

    coroutine.resume(coroutine.create(f))
  end
  ```

#### Return {#minipick.poke_is_picker_active-return}


`(boolean)` Whether there is an active picker.

#### See also {#minipick.poke_is_picker_active-seealso}


[`MiniPick.is_picker_active()`](mini-pick.qmd#minipick.is_picker_active)

